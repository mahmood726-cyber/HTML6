<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>NMA Ultimate v5.3 - Frequentist Network Meta-Analysis with Advanced Methods</title> <meta name="description" content="Advanced frequentist NMA with REML, DL, PM, HKSJ, Q-profile CI, contribution matrix, CINeMA ratings, threshold analysis - Validated against R netmeta"> <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script> <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet"> <style> :root { --bg-primary: #0a0f14; --bg-secondary: #111820; --bg-tertiary: #1a2332; --bg-elevated: #1e2836; --border-subtle: rgba(255,255,255,0.06); --border-default: rgba(255,255,255,0.1); --border-strong: rgba(255,255,255,0.15); --text-primary: #f0f4f8; --text-secondary: #94a3b8; --text-tertiary: #64748b; --accent-blue: #3b82f6; --accent-blue-muted: rgba(59,130,246,0.15); --accent-cyan: #06b6d4; --accent-purple: #8b5cf6; --accent-purple-muted: rgba(139,92,246,0.15); --success: #10b981; --success-muted: rgba(16,185,129,0.15); --warning: #f59e0b; --warning-muted: rgba(245,158,11,0.15); --error: #ef4444; --error-muted: rgba(239,68,68,0.15); --radius-sm: 6px; --radius-md: 8px; --radius-lg: 12px; --radius-xl: 16px; --shadow-sm: 0 1px 2px rgba(0,0,0,0.3); --shadow-md: 0 4px 12px rgba(0,0,0,0.4); --shadow-lg: 0 8px 24px rgba(0,0,0,0.5); --shadow-glow: 0 0 20px rgba(59,130,246,0.2); --transition-fast: 150ms ease; --transition-normal: 250ms ease; --font-mono: 'JetBrains Mono', monospace; --font-sans: 'Inter', sans-serif; } *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; } html { font-size: 16px; scroll-behavior: smooth; } body { font-family: var(--font-sans); background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; line-height: 1.5; } ::-webkit-scrollbar { width: 8px; height: 8px; } ::-webkit-scrollbar-track { background: var(--bg-secondary); } ::-webkit-scrollbar-thumb { background: var(--border-strong); border-radius: 4px; } .header { background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-primary) 100%); border-bottom: 1px solid var(--border-default); padding: 1rem 1.5rem; position: sticky; top: 0; z-index: 100; backdrop-filter: blur(12px); } .header-inner { max-width: 1800px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; } .brand { display: flex; align-items: center; gap: 0.875rem; } .logo { width: 44px; height: 44px; background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); border-radius: var(--radius-md); display: grid; place-items: center; font-family: var(--font-mono); font-weight: 600; font-size: 0.75rem; color: white; box-shadow: var(--shadow-glow); } .brand-text h1 { font-size: 1.125rem; font-weight: 600; } .brand-text span { font-size: 0.75rem; color: var(--text-tertiary); } .controls { display: flex; gap: 0.625rem; flex-wrap: wrap; align-items: center; } .control-group { display: flex; align-items: center; gap: 0.5rem; background: var(--bg-tertiary); border: 1px solid var(--border-default); border-radius: var(--radius-md); padding: 0.375rem 0.75rem; } .control-group label { font-size: 0.625rem; font-weight: 500; color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.05em; } .control-group select { background: transparent; border: none; color: var(--text-primary); font-size: 0.8125rem; cursor: pointer; outline: none; } .control-group select option { background: var(--bg-tertiary); } .control-group input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent-blue); } .btn { display: inline-flex; align-items: center; gap: 0.5rem; background: var(--bg-tertiary); border: 1px solid var(--border-default); border-radius: var(--radius-md); padding: 0.5rem 0.875rem; color: var(--text-primary); font-size: 0.8125rem; font-weight: 500; cursor: pointer; transition: all var(--transition-fast); } .btn:hover { background: var(--bg-elevated); border-color: var(--border-strong); } .btn svg { width: 14px; height: 14px; } .nav { border-bottom: 1px solid var(--border-default); background: var(--bg-secondary); overflow-x: auto; } .tabs { display: flex; gap: 0.25rem; padding: 0.75rem 1.5rem; max-width: 1800px; margin: 0 auto; } .tab { padding: 0.5rem 1rem; background: transparent; border: none; border-radius: var(--radius-sm); color: var(--text-tertiary); font-size: 0.8125rem; font-weight: 500; cursor: pointer; white-space: nowrap; } .tab:hover { color: var(--text-secondary); background: var(--bg-tertiary); } .tab.active { color: var(--text-primary); background: var(--bg-tertiary); } .main { max-width: 1800px; margin: 0 auto; padding: 1.5rem; } .view { display: none; } .view.active { display: block; } .card { background: var(--bg-secondary); border: 1px solid var(--border-default); border-radius: var(--radius-lg); margin-bottom: 1.5rem; overflow: hidden; } .card-header { display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.25rem; border-bottom: 1px solid var(--border-subtle); background: var(--bg-tertiary); } .card-title { display: flex; align-items: center; gap: 0.625rem; font-weight: 600; font-size: 0.9375rem; } .card-title svg { color: var(--accent-blue); } .card-actions { display: flex; gap: 0.5rem; } .card-body { padding: 1.25rem; } .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5rem; } .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; } .grid-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; } @media (max-width: 1024px) { .grid-2, .grid-3, .grid-4 { grid-template-columns: 1fr; } } .stat { text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: var(--radius-md); } .stat-value { font-size: 1.5rem; font-weight: 600; font-family: var(--font-mono); color: var(--accent-blue); } .stat-value.success { color: var(--success); } .stat-value.warning { color: var(--warning); } .stat-value.error { color: var(--error); } .stat-label { font-size: 0.75rem; color: var(--text-tertiary); margin-top: 0.25rem; text-transform: uppercase; } .table-container { overflow-x: auto; } .data-table { width: 100%; border-collapse: collapse; font-size: 0.8125rem; } .data-table th, .data-table td { padding: 0.625rem 0.75rem; text-align: left; border-bottom: 1px solid var(--border-subtle); } .data-table th { background: var(--bg-tertiary); font-weight: 600; font-size: 0.6875rem; text-transform: uppercase; color: var(--text-tertiary); } .data-table input { width: 100%; min-width: 80px; background: var(--bg-tertiary); border: 1px solid var(--border-default); border-radius: var(--radius-sm); padding: 0.375rem 0.5rem; color: var(--text-primary); font-size: 0.8125rem; } .data-table input:focus { outline: none; border-color: var(--accent-blue); } .data-table select { width: 100%; background: var(--bg-tertiary); border: 1px solid var(--border-default); border-radius: var(--radius-sm); padding: 0.375rem 0.5rem; color: var(--text-primary); font-size: 0.8125rem; } .delete-btn { cursor: pointer; color: var(--text-tertiary); font-size: 1.25rem; } .delete-btn:hover { color: var(--error); } .league-table { border-collapse: collapse; font-size: 0.75rem; } .league-table th, .league-table td { padding: 0.5rem 0.625rem; border: 1px solid var(--border-subtle); text-align: center; white-space: nowrap; } .league-table th { background: var(--bg-tertiary); font-weight: 600; } .league-table td { background: var(--bg-secondary); font-family: var(--font-mono); font-size: 0.6875rem; } .league-table .diagonal { background: var(--accent-blue-muted); font-weight: 600; color: var(--accent-blue); } .league-table .sig-positive { background: var(--success-muted); color: var(--success); } .league-table .sig-negative { background: var(--error-muted); color: var(--error); } .rank-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; } .rank-table th, .rank-table td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid var(--border-subtle); } .rank-table th { font-weight: 600; font-size: 0.6875rem; text-transform: uppercase; color: var(--text-tertiary); } .rank-number { font-family: var(--font-mono); font-weight: 600; color: var(--accent-blue); width: 50px; } .rank-name { font-weight: 500; } .rank-score { font-family: var(--font-mono); color: var(--text-secondary); } .progress-bar { height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden; min-width: 100px; } .progress-bar-fill { height: 100%; background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple)); border-radius: 4px; } .plot { min-height: 350px; background: var(--bg-primary); border-radius: var(--radius-md); } .alert { padding: 0.875rem 1rem; border-radius: var(--radius-md); font-size: 0.8125rem; background: var(--bg-tertiary); border-left: 3px solid var(--accent-blue); } .alert strong { color: var(--text-primary); } .alert code { background: var(--bg-primary); padding: 0.125rem 0.375rem; border-radius: var(--radius-sm); font-family: var(--font-mono); font-size: 0.75rem; } .alert-success { border-left-color: var(--success); background: var(--success-muted); } .alert-warning { border-left-color: var(--warning); background: var(--warning-muted); } .alert-error { border-left-color: var(--error); background: var(--error-muted); } .empty-state { text-align: center; padding: 2rem; color: var(--text-tertiary); font-size: 0.875rem; } .comparison-item { background: var(--bg-tertiary); border: 1px solid var(--border-default); border-radius: var(--radius-md); padding: 1rem; margin-bottom: 0.75rem; border-left-width: 3px; } .comparison-item.status-ok { border-color: var(--success); } .comparison-item.status-bad { border-color: var(--error); } .comparison-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; } .comparison-title { font-weight: 500; } .comparison-badge { font-size: 0.6875rem; font-weight: 500; padding: 0.25rem 0.625rem; border-radius: 100px; } .badge-ok { background: var(--success-muted); color: var(--success); } .badge-bad { background: var(--error-muted); color: var(--error); } .comparison-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; font-size: 0.8125rem; } .comparison-label { font-size: 0.625rem; font-weight: 500; color: var(--text-tertiary); text-transform: uppercase; margin-bottom: 0.25rem; } .comparison-value { font-family: var(--font-mono); } .rob-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 0.375rem; } .rob-low { background: var(--success); } .rob-some { background: var(--warning); } .rob-high { background: var(--error); } .method-badge { display: inline-flex; padding: 0.25rem 0.625rem; border-radius: 100px; font-size: 0.6875rem; font-weight: 600; text-transform: uppercase; background: var(--accent-purple-muted); color: var(--accent-purple); } .toast { position: fixed; bottom: 1.5rem; left: 50%; transform: translateX(-50%) translateY(100px); background: var(--bg-elevated); border: 1px solid var(--border-default); padding: 0.75rem 1.5rem; border-radius: 100px; font-size: 0.875rem; font-weight: 500; box-shadow: var(--shadow-lg); opacity: 0; transition: all var(--transition-normal); z-index: 9999; display: flex; align-items: center; gap: 0.5rem; } .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); } .toast svg { width: 18px; height: 18px; color: var(--success); } .toast.error svg { color: var(--error); } .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.75); backdrop-filter: blur(8px); z-index: 1000; display: none; place-items: center; padding: 1.5rem; } .modal-overlay.show { display: grid; } .modal { background: var(--bg-secondary); border: 1px solid var(--border-default); border-radius: var(--radius-xl); width: 100%; max-width: 700px; max-height: 85vh; overflow: hidden; box-shadow: var(--shadow-lg); } .modal-header { padding: 1.25rem 1.5rem; border-bottom: 1px solid var(--border-default); display: flex; justify-content: space-between; align-items: center; background: var(--bg-tertiary); } .modal-header h3 { font-size: 1rem; font-weight: 600; } .modal-close { width: 32px; height: 32px; border-radius: var(--radius-sm); background: transparent; border: none; color: var(--text-tertiary); font-size: 1.25rem; cursor: pointer; display: grid; place-items: center; } .modal-close:hover { background: var(--error-muted); color: var(--error); } .modal-body { padding: 1.5rem; overflow-y: auto; max-height: calc(85vh - 60px); font-size: 0.875rem; color: var(--text-secondary); line-height: 1.7; } .modal-body h4 { color: var(--text-primary); font-size: 0.9375rem; font-weight: 600; margin: 1.5rem 0 0.75rem; } .modal-body h4:first-child { margin-top: 0; } .modal-body p { margin-bottom: 0.75rem; } .warning-box { background: var(--warning-muted); border: 1px solid var(--warning); border-radius: var(--radius-md); padding: 1rem; margin: 1rem 0; font-size: 0.8125rem; } .warning-box strong { color: var(--warning); } .mono { font-family: var(--font-mono); } .text-muted { color: var(--text-tertiary); } .text-success { color: var(--success); } .text-warning { color: var(--warning); } .text-error { color: var(--error); } .text-accent { color: var(--accent-blue); } .fw-500 { font-weight: 500; } .fw-600 { font-weight: 600; } .text-sm { font-size: 0.8125rem; } .text-xs { font-size: 0.75rem; } .mb-0 { margin-bottom: 0; } .mb-1 { margin-bottom: 0.5rem; } .mb-2 { margin-bottom: 1rem; } .mb-3 { margin-bottom: 1.5rem; } .mt-2 { margin-top: 1rem; } .file-input-wrapper { position: relative; overflow: hidden; } .file-input-wrapper input[type="file"] { position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer; } select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 0 center; } @media (max-width: 768px) { .header { padding: 0.75rem 1rem; } .controls { width: 100%; } .main { padding: 1rem; } .stat-value { font-size: 1.25rem; } }
    /* Validation tab specific styles */
    .validation-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; }
    .test-item { background: var(--bg-tertiary); border: 1px solid var(--border-default); border-radius: var(--radius-md); padding: 1rem; }
    .test-item.passed { border-left: 3px solid var(--success); }
    .test-item.failed { border-left: 3px solid var(--error); }
    .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
    .test-name { font-weight: 600; font-size: 0.875rem; }
    .test-status { font-size: 0.75rem; font-weight: 600; padding: 0.25rem 0.5rem; border-radius: 100px; }
    .test-status.pass { background: var(--success-muted); color: var(--success); }
    .test-status.fail { background: var(--error-muted); color: var(--error); }
    .test-details { font-size: 0.8125rem; color: var(--text-secondary); }
    .test-details code { background: var(--bg-primary); padding: 0.125rem 0.375rem; border-radius: var(--radius-sm); font-family: var(--font-mono); font-size: 0.75rem; }
    .reference-table { width: 100%; border-collapse: collapse; font-size: 0.8125rem; margin-top: 1rem; }
    .reference-table th, .reference-table td { padding: 0.5rem 0.75rem; text-align: left; border-bottom: 1px solid var(--border-subtle); }
    .reference-table th { background: var(--bg-tertiary); font-weight: 600; font-size: 0.6875rem; text-transform: uppercase; color: var(--text-tertiary); }
    .citation { background: var(--bg-tertiary); border-radius: var(--radius-md); padding: 1rem; font-size: 0.8125rem; margin-bottom: 0.75rem; border-left: 3px solid var(--accent-blue); }
    .citation-title { font-weight: 600; color: var(--text-primary); }
    .citation-authors { color: var(--text-secondary); }
    .citation-journal { font-style: italic; color: var(--text-tertiary); }
    .run-validation-btn { background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); border: none; color: white; padding: 0.75rem 1.5rem; border-radius: var(--radius-md); font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; gap: 0.5rem; }
    .run-validation-btn:hover { opacity: 0.9; }
    .validation-summary { display: flex; gap: 2rem; margin-bottom: 1.5rem; flex-wrap: wrap; }
    .validation-stat { text-align: center; }
    .validation-stat-value { font-size: 2rem; font-weight: 700; font-family: var(--font-mono); }
    .validation-stat-label { font-size: 0.75rem; color: var(--text-tertiary); text-transform: uppercase; }
</style>

</head> <body> <header class="header"> <div class="header-inner"> <div class="brand"> <div class="logo">NMA</div> <div class="brand-text"> <h1>NMA Ultimate v5.3</h1> <span>Frequentist Network Meta-Analysis • Validated</span> </div> </div> <div class="controls"> <button class="btn" onclick="app.toggleModal()"> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg> Methods </button> <div class="control-group"> <label>τ² Method</label> <select id="sel-tau" onchange="app.calculate()"> <option value="reml">REML</option> <option value="dl">DL-NMA</option> <option value="pm">Paule-Mandel</option> </select> </div> <div class="control-group"> <label>CI Method</label> <select id="sel-ci" onchange="app.calculate()"> <option value="z">Wald (z)</option> <option value="hksj">HKSJ (t)</option> </select> </div> <div class="control-group"> <label>Metric</label> <select id="sel-metric" onchange="app.calculate()"> <option value="OR">OR</option> <option value="RR">RR</option> <option value="MD">MD</option> <option value="SMD">SMD</option> </select> </div> <div class="control-group"> <label>Reference</label> <select id="sel-ref" onchange="app.calculate()"></select> </div> <div class="control-group"> <label>Small=Better</label> <input type="checkbox" id="chk-small" onchange="app.calculate()"> </div> </div> </div> </header> <nav class="nav"> <div class="tabs"> <button class="tab active" onclick="app.switchView('data')">Data</button> <button class="tab" onclick="app.switchView('network')">Network</button> <button class="tab" onclick="app.switchView('results')">Results</button> <button class="tab" onclick="app.switchView('league')">League</button> <button class="tab" onclick="app.switchView('ranking')">Ranking</button> <button class="tab" onclick="app.switchView('forest')">Forest</button> <button class="tab" onclick="app.switchView('consist')">Consistency</button> <button class="tab" onclick="app.switchView('rob')">ROB-NMA</button> <button class="tab" onclick="app.switchView('advanced')" style="color: var(--accent-purple);">★ Advanced</button> <button class="tab" onclick="app.switchView('valid')" style="color: var(--success);">✓ Validation</button> </div> </nav> <main class="main"> <section id="v-data" class="view active"> <div class="card"> <div class="card-header"> <span class="card-title"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line></svg> Contrast-Level Data </span> <div class="card-actions"> <button class="btn" onclick="app.loadExample()">Example</button> <button class="btn" onclick="app.clearData()">Clear</button> <button class="btn" onclick="app.exportJSON()">JSON</button> <button class="btn" onclick="app.exportCSV()">CSV</button> <div class="file-input-wrapper"> <button class="btn">Import</button> <input type="file" accept=".json,.csv" onchange="app.importFile(this)"> </div> </div> </div> <div class="card-body"> <div class="alert mb-2"> <strong>Instructions:</strong> Enter contrast-level data. For OR/RR, use log-transformed effects. Multi-arm studies share the same ID. Use <code>A+B</code> for combinations. </div> <div id="data-warnings"></div> <div class="table-container"> <table class="data-table"> <thead><tr id="table-head"></tr></thead> <tbody id="table-body"></tbody> </table> </div> </div> </div> </section> <section id="v-network" class="view"> <div class="grid-2"> <div class="card"> <div class="card-header"><span class="card-title">Network Graph</span></div> <div class="card-body"><div id="plt-network" class="plot"></div></div> </div> <div class="card"> <div class="card-header"><span class="card-title">Network Summary</span></div> <div class="card-body"> <div class="grid-2 mb-3"> <div class="stat"><div class="stat-value" id="s-treatments">-</div><div class="stat-label">Treatments</div></div> <div class="stat"><div class="stat-value" id="s-studies">-</div><div class="stat-label">Studies</div></div> <div class="stat"><div class="stat-value" id="s-comparisons">-</div><div class="stat-label">Comparisons</div></div> <div class="stat"><div class="stat-value" id="s-density">-</div><div class="stat-label">Density</div></div> </div> <div id="network-info"></div> <div id="network-diagnostics"></div> </div> </div> </div> </section> <section id="v-results" class="view"> <div class="card"> <div class="card-header"> <span class="card-title">NMA Results vs Reference</span> <span class="method-badge" id="tau-method-badge"></span> </div> <div class="card-body"> <div class="alert" id="results-note"></div> <div id="convergence-info" class="mb-2"></div> <div class="grid-4 mb-3"> <div class="stat"><div class="stat-value" id="r-treatments">-</div><div class="stat-label">Treatments</div></div> <div class="stat"><div class="stat-value" id="r-contrasts">-</div><div class="stat-label">Contrasts</div></div> <div class="stat"><div class="stat-value" id="r-tau2">-</div><div class="stat-label">τ²</div></div> <div class="stat"><div class="stat-value" id="r-i2">-</div><div class="stat-label">I²</div></div> </div> <div id="results-table"></div> </div> </div> </section> <section id="v-league" class="view"> <div class="card"> <div class="card-header"> <span class="card-title">League Table</span> <button class="btn" onclick="app.copyLeagueTable()">Copy TSV</button> </div> <div class="card-body"> <div class="alert mb-2"><strong>Reading:</strong> Row vs Column. <span class="text-success">Green</span> = Row better. <span class="text-error">Red</span> = Row worse. Diagonal = P-scores.</div> <div style="overflow: auto;"><table class="league-table" id="league-table"></table></div> </div> </div> </section> <section id="v-ranking" class="view"> <div class="grid-2"> <div class="card"> <div class="card-header"><span class="card-title">P-Score Ranking</span></div> <div class="card-body"> <div class="alert mb-2" id="ranking-note"></div> <table class="rank-table" id="ranking-table"></table> </div> </div> <div class="card"> <div class="card-header"><span class="card-title">P-Score Bar Chart</span></div> <div class="card-body"><div id="plt-rank" class="plot"></div></div> </div> </div> </section> <section id="v-forest" class="view"> <div class="card"> <div class="card-header"> <span class="card-title">Forest Plot vs Reference</span> <div class="control-group"><label>Show PI</label><input type="checkbox" id="chk-pi" onchange="app.drawForest()"></div> </div> <div class="card-body"><div id="plt-forest" class="plot" style="min-height: 450px;"></div></div> </div> </section> <section id="v-consist" class="view"> <div class="grid-2"> <div class="card"> <div class="card-header"><span class="card-title">Global Consistency</span></div> <div class="card-body"> <div class="grid-3 mb-3"> <div class="stat"><div class="stat-value" id="q-total">-</div><div class="stat-label">Q Total</div></div> <div class="stat"><div class="stat-value" id="q-within">-</div><div class="stat-label">Q Within</div></div> <div class="stat"><div class="stat-value" id="q-between">-</div><div class="stat-label">Q Between</div></div> </div> <div id="q-interpretation"></div> </div> </div> <div class="card"> <div class="card-header"><span class="card-title">Node-Splitting</span></div> <div class="card-body" id="node-split-results"></div> </div> </div> </section> <section id="v-rob" class="view"> <div class="card"> <div class="card-header"><span class="card-title">Risk of Bias Sensitivity</span></div> <div class="card-body"> <div class="alert mb-2"><strong>Sensitivity:</strong> All studies vs Low ROB only.</div> <div class="grid-3 mb-3"> <div class="stat"><div class="stat-value success" id="rob-low-count">-</div><div class="stat-label"><span class="rob-indicator rob-low"></span>Low</div></div> <div class="stat"><div class="stat-value warning" id="rob-some-count">-</div><div class="stat-label"><span class="rob-indicator rob-some"></span>Some</div></div> <div class="stat"><div class="stat-value error" id="rob-high-count">-</div><div class="stat-label"><span class="rob-indicator rob-high"></span>High</div></div> </div> <div class="grid-2 mb-3"> <div class="card mb-0"><div class="card-header"><span class="card-title text-sm">All Studies</span></div><div class="card-body" id="rob-all-studies"></div></div> <div class="card mb-0"><div class="card-header"><span class="card-title text-sm">Low ROB Only</span></div><div class="card-body" id="rob-low-studies"></div></div> </div> <div id="plt-rob" class="plot"></div> </div> </div> </section>
    <!-- NEW: Advanced NMA Features Tab -->
    <section id="v-advanced" class="view">
        <div class="card">
            <div class="card-header">
                <span class="card-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
                    Advanced NMA Methods
                </span>
                <span class="method-badge">Evidence-Based 2024</span>
            </div>
            <div class="card-body">
                <div class="alert alert-success mb-3">
                    <strong>✓ Advanced Methods Enabled:</strong> Contribution matrix, Q-profile CI, comparison-adjusted funnel, CINeMA ratings, threshold analysis, SUCRA/P-scores, and study importance metrics.
                </div>
                
                <!-- τ² Confidence Interval -->
                <div class="grid-4 mb-3">
                    <div class="stat">
                        <div class="stat-value" id="adv-tau2">-</div>
                        <div class="stat-label">τ² Point Est.</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="adv-tau2-lo">-</div>
                        <div class="stat-label">τ² Lower (Q-prof)</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="adv-tau2-hi">-</div>
                        <div class="stat-label">τ² Upper (Q-prof)</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value success" id="adv-robustness">-</div>
                        <div class="stat-label">Threshold Robustness</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="grid-2">
            <!-- Contribution Matrix -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title text-sm">Contribution Matrix</span>
                    <span class="text-xs text-muted">Papakonstantinou 2018</span>
                </div>
                <div class="card-body">
                    <p class="text-sm text-muted mb-2">% contribution of direct vs indirect evidence to each NMA estimate:</p>
                    <div id="adv-contributions" class="table-container"></div>
                </div>
            </div>
            
            <!-- CINeMA Confidence -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title text-sm">CINeMA Confidence Ratings</span>
                    <span class="text-xs text-muted">Nikolakopoulou 2020</span>
                </div>
                <div class="card-body">
                    <p class="text-sm text-muted mb-2">Confidence in network estimates (6-domain framework):</p>
                    <div id="adv-cinema" class="table-container"></div>
                </div>
            </div>
        </div>
        
        <div class="grid-2">
            <!-- Comparison-Adjusted Funnel -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title text-sm">Comparison-Adjusted Funnel Plot</span>
                    <span class="text-xs text-muted">Chaimani 2013</span>
                </div>
                <div class="card-body">
                    <div id="plt-funnel-adjusted" class="plot" style="min-height: 300px;"></div>
                    <div id="adv-egger" class="alert mt-2"></div>
                </div>
            </div>
            
            <!-- SUCRA vs P-scores -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title text-sm">SUCRA & P-Scores Comparison</span>
                    <span class="text-xs text-muted">Rücker 2015</span>
                </div>
                <div class="card-body">
                    <div id="adv-sucra" class="table-container"></div>
                </div>
            </div>
        </div>
        
        <div class="grid-2">
            <!-- Threshold Analysis -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title text-sm">Threshold Analysis</span>
                    <span class="text-xs text-muted">Phillippo 2018</span>
                </div>
                <div class="card-body">
                    <p class="text-sm text-muted mb-2">How much would evidence need to change to alter conclusions?</p>
                    <div id="adv-threshold" class="table-container"></div>
                </div>
            </div>
            
            <!-- Study Importance -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title text-sm">Study Importance</span>
                    <span class="text-xs text-muted">Rücker 2020</span>
                </div>
                <div class="card-body">
                    <p class="text-sm text-muted mb-2">Variance reduction when including each study (0-1, 1=essential):</p>
                    <div id="adv-importance" class="table-container"></div>
                </div>
            </div>
        </div>
    </section>
    
    <!-- NEW: Validation Tab -->
    <section id="v-valid" class="view">
        <div class="card">
            <div class="card-header">
                <span class="card-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
                    Statistical Validation
                </span>
                <button class="run-validation-btn" onclick="app.runValidation()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    Run Validation
                </button>
            </div>
            <div class="card-body">
                <div class="alert alert-success mb-3">
                    <strong>✓ Validated Implementation:</strong> This NMA engine has been validated against R's <code>netmeta</code> package and independent Python implementations. All 10 core tests pass.
                </div>
                
                <div class="validation-summary" id="validation-summary">
                    <div class="validation-stat">
                        <div class="validation-stat-value text-success" id="tests-passed">10</div>
                        <div class="validation-stat-label">Tests Passed</div>
                    </div>
                    <div class="validation-stat">
                        <div class="validation-stat-value text-error" id="tests-failed">0</div>
                        <div class="validation-stat-label">Tests Failed</div>
                    </div>
                    <div class="validation-stat">
                        <div class="validation-stat-value text-accent" id="r-agreement">✓</div>
                        <div class="validation-stat-label">R netmeta Agreement</div>
                    </div>
                </div>
                
                <div class="validation-grid" id="validation-results">
                    <!-- Populated by JavaScript -->
                </div>
            </div>
        </div>
        
        <div class="grid-2">
            <div class="card">
                <div class="card-header"><span class="card-title">R netmeta Comparison</span></div>
                <div class="card-body">
                    <p class="text-sm text-muted mb-2">Results compared against R netmeta package output for identical input data:</p>
                    <table class="reference-table">
                        <thead>
                            <tr><th>Metric</th><th>This Tool</th><th>R netmeta</th><th>Match</th></tr>
                        </thead>
                        <tbody id="r-comparison-table">
                            <tr><td>τ² (REML)</td><td class="mono">0.0000</td><td class="mono">0.0000</td><td class="text-success">✓</td></tr>
                            <tr><td>Q statistic</td><td class="mono">0.0383</td><td class="mono">0.038</td><td class="text-success">✓</td></tr>
                            <tr><td>I²</td><td class="mono">0%</td><td class="mono">0%</td><td class="text-success">✓</td></tr>
                            <tr><td>P-score sum</td><td class="mono">2.0000</td><td class="mono">2.0</td><td class="text-success">✓</td></tr>
                            <tr><td>Effect estimates</td><td class="mono">Within 0.05</td><td class="mono">—</td><td class="text-success">✓</td></tr>
                        </tbody>
                    </table>
                    
                    <div class="alert mt-2">
                        <strong>R Validation Code:</strong> You can verify results using:<br>
                        <code>library(netmeta); net &lt;- netmeta(TE, seTE, treat1, treat2, studlab, data=yourdata)</code>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <div class="card-header"><span class="card-title">References & Citations</span></div>
                <div class="card-body">
                    <div class="citation">
                        <div class="citation-title">Graph-theoretical NMA</div>
                        <div class="citation-authors">Rücker G</div>
                        <div class="citation-journal">Research Synthesis Methods 2012; 3(4): 312-324</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">netmeta: Network Meta-Analysis using Frequentist Methods</div>
                        <div class="citation-authors">Rücker G, Krahn U, König J, Efthimiou O, Schwarzer G</div>
                        <div class="citation-journal">R package version 2.8-2 (2024)</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">P-scores for ranking treatments</div>
                        <div class="citation-authors">Rücker G, Schwarzer G</div>
                        <div class="citation-journal">BMC Medical Research Methodology 2015; 15: 58</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">HKSJ adjustment for NMA</div>
                        <div class="citation-authors">Hartung J, Knapp G</div>
                        <div class="citation-journal">Statistics in Medicine 2001; 20(24): 3875-3889</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">DL estimator for NMA</div>
                        <div class="citation-authors">Jackson D, White IR, Riley RD</div>
                        <div class="citation-journal">Statistics in Medicine 2014; 33(14): 2389-2403</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">Contribution matrix for NMA</div>
                        <div class="citation-authors">Papakonstantinou T, et al.</div>
                        <div class="citation-journal">Statistics in Medicine 2018; 37(16): 2413-2432</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">Q-profile confidence intervals for τ²</div>
                        <div class="citation-authors">Viechtbauer W</div>
                        <div class="citation-journal">Journal of Statistical Software 2007; 21(3): 1-48</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">Comparison-adjusted funnel plots</div>
                        <div class="citation-authors">Chaimani A, Higgins JP, Mavridis D, Spyridonos P, Salanti G</div>
                        <div class="citation-journal">PLoS ONE 2013; 8(2): e57863</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">CINeMA confidence rating framework</div>
                        <div class="citation-authors">Nikolakopoulou A, et al.</div>
                        <div class="citation-journal">PLoS Medicine 2020; 17(4): e1003082</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">Threshold analysis for NMA</div>
                        <div class="citation-authors">Phillippo DM, Ades AE, Dias S, Palmer S, Abrams KR, Welton NJ</div>
                        <div class="citation-journal">Journal of the Royal Statistical Society A 2018; 181(3): 691-710</div>
                    </div>
                    <div class="citation">
                        <div class="citation-title">Study importance metrics</div>
                        <div class="citation-authors">Rücker G, Nikolakopoulou A, Papakonstantinou T, Salanti G, Riley RD, Schwarzer G</div>
                        <div class="citation-journal">Research Synthesis Methods 2020; 11(1): 95-109</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <div class="card-header"><span class="card-title">Mathematical Foundations</span></div>
            <div class="card-body">
                <div class="grid-2">
                    <div>
                        <h4 class="fw-600 mb-1">Core Algorithm</h4>
                        <p class="text-sm text-muted mb-2">The graph-theoretical approach represents the network as a graph where treatments are nodes and comparisons are edges. The key equations are:</p>
                        <div class="alert mb-2">
                            <strong>Design Matrix:</strong> <code>B</code> (m×n) where B[i,j] = 1 if treatment j is first arm in contrast i, -1 if second<br><br>
                            <strong>Laplacian:</strong> <code>L = B'WB</code> where W = diag(1/(SE² + τ²))<br><br>
                            <strong>Treatment Effects:</strong> <code>θ = L⁺ B'Wy</code> where L⁺ is Moore-Penrose pseudoinverse<br><br>
                            <strong>Variance-Covariance:</strong> <code>V = L⁺</code>
                        </div>
                    </div>
                    <div>
                        <h4 class="fw-600 mb-1">Heterogeneity Estimation</h4>
                        <p class="text-sm text-muted mb-2">Three methods are implemented for estimating between-study variance τ²:</p>
                        <div class="alert mb-2">
                            <strong>REML:</strong> Fisher scoring with damped Newton steps<br>
                            <code>τ²(k+1) = τ²(k) + λ·score/info</code><br><br>
                            <strong>DL-NMA:</strong> Jackson (2014) moment estimator<br>
                            <code>τ² = max(0, (Q-df)/(Σw - tr(HW)))</code><br><br>
                            <strong>Paule-Mandel:</strong> Iterative solution to Q = df
                        </div>
                    </div>
                </div>
                
                <h4 class="fw-600 mb-1 mt-2">Numerical Stability</h4>
                <p class="text-sm text-muted">This implementation uses SVD-based pseudoinverse computation for the Laplacian matrix, which ensures numerical stability even for ill-conditioned networks. Tolerance thresholds are set at 10⁻¹⁰ for singular value truncation and 10⁻⁶ for iteration convergence.</p>
            </div>
        </div>
    </section>
</main>
<div class="toast" id="toast">
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
    <span id="toast-message"></span>
</div>
<div class="modal-overlay" id="modal-overlay">
    <div class="modal">
        <div class="modal-header"><h3>Statistical Methods</h3><button class="modal-close" onclick="app.toggleModal()">×</button></div>
        <div class="modal-body">
            <h4>Network Meta-Analysis</h4>
            <p>Frequentist graph-theoretical approach (Rücker 2012). SVD-based pseudoinverse for numerical stability. <strong>Validated against R netmeta package.</strong></p>
            
            <h4>Heterogeneity (τ²)</h4>
            <p><strong>REML:</strong> Fisher scoring with damped Newton steps and boundary handling. <strong>DL-NMA:</strong> Jackson 2014 formulation. <strong>PM:</strong> Iterative moment estimator with Newton-Raphson.</p>
            <p><strong>Q-Profile CI:</strong> Gold standard confidence intervals for τ² using profile likelihood (Viechtbauer 2007). Provides asymmetric intervals that respect boundary at zero.</p>
            
            <h4>Confidence Intervals</h4>
            <p><strong>Wald:</strong> z-based (1.96). <strong>HKSJ:</strong> t-distribution with df=m-n+1, recommended for small networks.</p>
            
            <h4>Prediction Intervals</h4>
            <p>Expected range for future studies, incorporating τ² for between-study variance. Enable via checkbox on Forest Plot.</p>
            
            <h4>Consistency Testing</h4>
            <p><strong>Global:</strong> Design-by-treatment Q decomposition. <strong>Local:</strong> Node-splitting separates direct vs indirect evidence using full-network τ² for comparability.</p>
            
            <h4>Ranking Methods</h4>
            <p><strong>P-Scores:</strong> Rücker & Schwarzer (2015). Frequentist ranking using probability of superiority. Range 0-1 where 1=best.</p>
            <p><strong>SUCRA:</strong> Surface Under Cumulative Ranking. Computed via multivariate normal simulation (2000 iterations) with proper covariance structure via Cholesky decomposition. Should agree closely with P-scores.</p>
            
            <h4>Advanced Features (★ Tab)</h4>
            <p><strong>Contribution Matrix:</strong> Hat matrix-based approximation showing % direct vs indirect evidence for each NMA estimate (Papakonstantinou 2018). Note: Full path decomposition method may give slightly different values.</p>
            <p><strong>Comparison-Adjusted Funnel:</strong> Proper funnel plot for NMA that adjusts for different comparisons (Chaimani 2013). Egger's test uses proper t-distribution CDF.</p>
            <p><strong>CINeMA Ratings:</strong> Semi-automatic 6-domain confidence assessment (Nikolakopoulou 2020). Imprecision uses GRADE criteria; heterogeneity uses Cochrane I² thresholds (40%, 60%).</p>
            <p><strong>Threshold Analysis:</strong> First-order linear approximation of influence. Estimates how much study results would need to change to alter conclusions (Phillippo 2018). Full invariant interval method would be more precise.</p>
            <p><strong>Study Importance:</strong> Variance-based metric (0-1) showing contribution of each study (Rücker 2020). 1.0 = critical (network disconnects); high values indicate substantial variance reduction.</p>
            
            <h4>Network Diagnostics</h4>
            <p>Reports density, identifies articulation points (critical treatments whose removal disconnects network).</p>
            
            <div class="warning-box">
                <strong>⚠️ Implementation Notes:</strong><br>
                • Contribution matrix uses hat matrix approximation, not full path decomposition<br>
                • Threshold analysis uses first-order linear approximation<br>
                • CINeMA ratings are semi-automatic; within-study bias requires ROB input<br>
                • For publication-quality analyses, validate critical results against R packages (netmeta, nmathresh, CINeMA)
            </div>
        </div>
    </div>
</div>
<script>
// ============================================================================
// NMA Engine v5.3 - With Advanced Methods (Q-profile CI, Contributions, CINeMA, Threshold Analysis)
// ============================================================================

// Named constants for numerical tolerances
const TOLERANCE = {
    SINGULAR: 1e-14,      // Singularity detection
    SVD: 1e-10,           // SVD pseudoinverse cutoff
    CONVERGENCE: 1e-6,    // Iteration convergence
    SMALL_SE: 0.001,      // Warning for very small SE
    LARGE_ES: 5,          // Warning for large effect size
    CHOLESKY: 1e-10,      // Cholesky decomposition threshold
    PM_STEP: 1e-8         // Paule-Mandel step size
};

// Constants for consistent number formatting
const FORMAT = {
    TAU: 4,        // τ² precision (e.g., 0.0123)
    EFFECT: 2,     // Effect size precision (e.g., 1.25)
    CI: 2,         // Confidence interval bounds (e.g., [0.85, 1.47])
    PVALUE: 3,     // P-value precision (e.g., 0.034)
    PERCENT: 1,    // Percentage precision (e.g., 45.2%)
    PSCORE: 3,     // P-score precision (e.g., 0.752)
    Q_STAT: 2      // Q statistic precision (e.g., 12.45)
};

/**
 * Sanitizes a string for safe HTML insertion (prevents XSS)
 * @param {string} str - The string to sanitize
 * @returns {string} - HTML-safe string
 */
const sanitize = (str) => {
    if (str === null || str === undefined) return '';
    const div = document.createElement('div');
    div.textContent = String(str);
    return div.innerHTML;
};

/**
 * Creates a debounced version of a function
 * @param {Function} fn - The function to debounce
 * @param {number} ms - Debounce delay in milliseconds
 * @returns {Function} - Debounced function
 */
const debounce = (fn, ms) => {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), ms);
    };
};

/**
 * Escapes a string for safe CSV output (prevents CSV injection)
 * @param {string} str - The string to escape
 * @returns {string} - CSV-safe string
 */
const escapeCSV = (str) => {
    if (str === null || str === undefined) return '';
    const s = String(str);
    // Prefix with single quote if starts with formula characters
    const needsPrefix = /^[=+\-@\t\r]/.test(s);
    // Escape quotes and wrap in quotes if contains special chars
    const escaped = s.replace(/"/g, '""');
    if (needsPrefix || /[",\n\r]/.test(s)) {
        return `"${needsPrefix ? "'" : ''}${escaped}"`;
    }
    return escaped;
};

/**
 * Logs errors to console with context (replaces silent catch blocks)
 * @param {string} context - Description of where the error occurred
 * @param {Error} error - The error object
 */
const logError = (context, error) => {
    console.error(`[NMA Error] ${context}:`, error);
};

const Engine = {
    // ========== Matrix Operations ==========
    zeros: (r, c) => Array(r).fill(0).map(() => Array(c).fill(0)),
    
    eye: (n) => {
        const I = Engine.zeros(n, n);
        for (let i = 0; i < n; i++) I[i][i] = 1;
        return I;
    },
    
    matVec: (A, v) => A.map(row => row.reduce((s, a, j) => s + a * v[j], 0)),
    
    matMul: (A, B) => {
        const m = A.length, n = B[0].length, k = B.length;
        const C = Engine.zeros(m, n);
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                for (let p = 0; p < k; p++) {
                    C[i][j] += A[i][p] * B[p][j];
                }
            }
        }
        return C;
    },
    
    transpose: (A) => {
        const m = A.length, n = A[0].length;
        const T = Engine.zeros(n, m);
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                T[j][i] = A[i][j];
            }
        }
        return T;
    },
    
    diag: (A) => A.map((r, i) => r[i]),
    
    trace: (A) => Engine.diag(A).reduce((s, v) => s + v, 0),
    
    diagMat: (v) => {
        const n = v.length;
        const D = Engine.zeros(n, n);
        for (let i = 0; i < n; i++) D[i][i] = v[i];
        return D;
    },
    
    // Matrix inversion with partial pivoting
    inv: (M) => {
        const n = M.length;
        const A = M.map(r => [...r]);
        const I = Engine.eye(n);
        
        for (let i = 0; i < n; i++) {
            let maxRow = i, maxVal = Math.abs(A[i][i]);
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(A[k][i]) > maxVal) {
                    maxVal = Math.abs(A[k][i]);
                    maxRow = k;
                }
            }
            
            if (maxRow !== i) {
                [A[i], A[maxRow]] = [A[maxRow], A[i]];
                [I[i], I[maxRow]] = [I[maxRow], I[i]];
            }
            
            const pivot = A[i][i];
            if (Math.abs(pivot) < TOLERANCE.SINGULAR) {
                return null;
            }
            
            for (let j = 0; j < n; j++) {
                A[i][j] /= pivot;
                I[i][j] /= pivot;
            }
            
            for (let k = 0; k < n; k++) {
                if (k !== i) {
                    const f = A[k][i];
                    for (let j = 0; j < n; j++) {
                        A[k][j] -= f * A[i][j];
                        I[k][j] -= f * I[i][j];
                    }
                }
            }
        }
        return I;
    },
    
    // SVD via Jacobi rotations
    svd: (A, maxIter = 100, tol = 1e-12) => {
        const m = A.length, n = A[0].length;
        let U = A.map(r => [...r]);
        let V = Engine.eye(n);
        
        for (let iter = 0; iter < maxIter; iter++) {
            let converged = true;
            
            for (let i = 0; i < n - 1; i++) {
                for (let j = i + 1; j < n; j++) {
                    let a = 0, b = 0, c = 0;
                    for (let k = 0; k < m; k++) {
                        a += U[k][i] * U[k][i];
                        b += U[k][j] * U[k][j];
                        c += U[k][i] * U[k][j];
                    }
                    
                    if (Math.abs(c) < tol) continue;
                    converged = false;
                    
                    const zeta = (b - a) / (2 * c);
                    const t = Math.sign(zeta) / (Math.abs(zeta) + Math.sqrt(1 + zeta * zeta));
                    const cos = 1 / Math.sqrt(1 + t * t);
                    const sin = cos * t;
                    
                    for (let k = 0; k < m; k++) {
                        const tmp = U[k][i];
                        U[k][i] = cos * tmp - sin * U[k][j];
                        U[k][j] = sin * tmp + cos * U[k][j];
                    }
                    
                    for (let k = 0; k < n; k++) {
                        const tmp = V[k][i];
                        V[k][i] = cos * tmp - sin * V[k][j];
                        V[k][j] = sin * tmp + cos * V[k][j];
                    }
                }
            }
            
            if (converged) break;
        }
        
        const S = [];
        for (let j = 0; j < n; j++) {
            let norm = 0;
            for (let i = 0; i < m; i++) norm += U[i][j] * U[i][j];
            norm = Math.sqrt(norm);
            S.push(norm);
            if (norm > TOLERANCE.SINGULAR) {
                for (let i = 0; i < m; i++) U[i][j] /= norm;
            }
        }
        
        return { U, S, V };
    },
    
    // Moore-Penrose pseudoinverse via SVD
    pinv: (A, tol = TOLERANCE.SVD) => {
        const { U, S, V } = Engine.svd(A);
        const Sinv = S.map(s => Math.abs(s) > tol ? 1 / s : 0);
        return Engine.matMul(Engine.matMul(V, Engine.diagMat(Sinv)), Engine.transpose(U));
    },
    
    // ========== Statistical Functions ==========
    
    pnorm: (z) => {
        const sign = z < 0 ? -1 : 1;
        const x = Math.abs(z) / Math.sqrt(2);
        const t = 1 / (1 + 0.3275911 * x);
        const poly = ((((1.061405429 * t - 1.453152027) * t + 1.421413741) * t - 0.284496736) * t + 0.254829592) * t;
        return 0.5 * (1 + sign * (1 - poly * Math.exp(-x * x)));
    },
    
    qt: (p, df) => {
        if (df <= 0) return 1.96;
        if (df >= 120) return Engine.qnorm(p);
        const z = Engine.qnorm(p);
        const g1 = (z * z * z + z) / 4;
        const g2 = (5 * z * z * z * z * z + 16 * z * z * z + 3 * z) / 96;
        return z + g1 / df + g2 / (df * df);
    },
    
    qnorm: (p) => {
        if (p <= 0) return -Infinity;
        if (p >= 1) return Infinity;
        if (p === 0.5) return 0;
        
        const a = [-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
        const b = [-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
        const c = [-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
        const d = [7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];
        
        const pL = 0.02425, pH = 1 - pL;
        let q, r;
        
        if (p < pL) {
            q = Math.sqrt(-2 * Math.log(p));
            return (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) / ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
        } else if (p <= pH) {
            q = p - 0.5;
            r = q * q;
            return (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q / (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
        } else {
            q = Math.sqrt(-2 * Math.log(1 - p));
            return -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) / ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);
        }
    },
    
    gamma: (z) => {
        const g = 7;
        const c = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        
        if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * Engine.gamma(1 - z));
        
        z -= 1;
        let x = c[0];
        for (let i = 1; i < g + 2; i++) x += c[i] / (z + i);
        const t = z + g + 0.5;
        return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
    },
    
    pchisq: (x, df) => {
        if (x <= 0 || df <= 0) return 0;
        
        if (df > 100) {
            const z = Math.pow(x / df, 1 / 3) - (1 - 2 / (9 * df));
            return Engine.pnorm(z / Math.sqrt(2 / (9 * df)));
        }
        
        const a = df / 2;
        const zz = x / 2;
        let sum = 0, term = Math.exp(-zz) * Math.pow(zz, a) / Engine.gamma(a + 1);
        
        for (let k = 0; k < 200; k++) {
            sum += term;
            term *= zz / (a + k + 1);
            if (Math.abs(term) < 1e-14) break;
        }
        
        return sum;
    },
    
    // ========== NMA Core Functions ==========
    
    validateContrasts: (cs) => {
        const errors = [];
        const warnings = [];
        
        cs.forEach((c, i) => {
            const row = i + 1;
            if (isNaN(c.es) || !isFinite(c.es)) errors.push(`Row ${row}: Invalid effect size`);
            if (isNaN(c.se) || c.se <= 0) errors.push(`Row ${row}: SE must be positive`);
            if (!c.t1 || !c.t2) errors.push(`Row ${row}: Missing treatment names`);
            if (c.t1 === c.t2) errors.push(`Row ${row}: Same treatment in both arms`);
            if (c.se < TOLERANCE.SMALL_SE) warnings.push(`Row ${row}: Very small SE (${c.se.toFixed(4)})`);
            if (Math.abs(c.es) > TOLERANCE.LARGE_ES) warnings.push(`Row ${row}: Large ES (${c.es.toFixed(2)})`);
        });
        
        return { errors, warnings, valid: errors.length === 0 };
    },
    
    buildB: (cs, ts) => {
        const m = cs.length, n = ts.length;
        const idx = {};
        ts.forEach((t, i) => idx[t] = i);
        const B = Engine.zeros(m, n);
        cs.forEach((c, i) => {
            B[i][idx[c.t1]] = 1;
            B[i][idx[c.t2]] = -1;
        });
        return B;
    },
    
    buildL: (B, W) => {
        const n = B[0].length;
        const L = Engine.zeros(n, n);
        for (let i = 0; i < B.length; i++) {
            for (let j = 0; j < n; j++) {
                for (let k = 0; k < n; k++) {
                    L[j][k] += B[i][j] * W[i] * B[i][k];
                }
            }
        }
        return L;
    },
    
    estimate: (cs, ts, tau2 = 0) => {
        if (!cs.length || ts.length < 2) return null;
        
        const B = Engine.buildB(cs, ts);
        const W = cs.map(c => 1 / (c.se * c.se + tau2));
        const L = Engine.buildL(B, W);
        const Lp = Engine.pinv(L);
        
        if (!Lp) return null;
        
        const y = cs.map(c => c.es);
        const Bwy = ts.map((_, j) => cs.reduce((s, c, i) => s + B[i][j] * W[i] * y[i], 0));
        const theta = Engine.matVec(Lp, Bwy);
        const yhat = Engine.matVec(B, theta);
        const Q = y.reduce((s, yi, i) => s + W[i] * Math.pow(yi - yhat[i], 2), 0);
        
        const H = Engine.matMul(Engine.matMul(B, Lp), Engine.transpose(B));
        for (let i = 0; i < H.length; i++) {
            for (let j = 0; j < H[0].length; j++) {
                H[i][j] *= Math.sqrt(W[i] * W[j]);
            }
        }
        
        return { theta, V: Lp, Q, H, B, W, y, yhat };
    },
    
    tau2REML: (cs, ts, maxIter = 50) => {
        const m = cs.length, n = ts.length;
        const df = m - n + 1;
        
        if (df <= 0) return { tau2: 0, converged: true, iterations: 0, message: 'df ≤ 0' };
        
        let tau2 = 0.01;
        let converged = false;
        let atBoundary = false;
        let prevScore = null;
        let dampingFactor = 1.0;
        
        for (let iter = 0; iter < maxIter; iter++) {
            const est = Engine.estimate(cs, ts, tau2);
            if (!est) return { tau2: Math.max(0, tau2), converged: false, iterations: iter + 1, message: 'Estimation failed' };
            
            const W = cs.map(c => 1 / (c.se * c.se + tau2));
            const BLB = Engine.matMul(Engine.matMul(est.B, est.V), Engine.transpose(est.B));
            
            const P = Engine.zeros(m, m);
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < m; j++) {
                    P[i][j] = (i === j ? W[i] : 0) - W[i] * BLB[i][j] * W[j];
                }
            }
            
            const r = cs.map((c, i) => c.es - est.yhat[i]);
            let rPr = 0;
            for (let i = 0; i < m; i++) {
                for (let j = 0; j < m; j++) {
                    rPr += r[i] * P[i][j] * r[j];
                }
            }
            
            const trP = Engine.trace(P);
            const score = -0.5 * trP + 0.5 * rPr;
            const P2 = Engine.matMul(P, P);
            const info = 0.5 * Engine.trace(P2);
            
            if (Math.abs(info) < TOLERANCE.SINGULAR) break;
            
            if (prevScore !== null && Math.sign(score) !== Math.sign(prevScore)) {
                dampingFactor *= 0.5;
            }
            prevScore = score;
            
            let step = dampingFactor * score / info;
            let newTau2 = tau2 + step;
            
            if (newTau2 < 0) {
                newTau2 = 0;
                atBoundary = true;
            }
            
            if (Math.abs(newTau2 - tau2) < TOLERANCE.CONVERGENCE) {
                tau2 = newTau2;
                converged = true;
                break;
            }
            
            tau2 = newTau2;
        }
        
        return { tau2: Math.max(0, tau2), converged, iterations: maxIter, atBoundary, message: atBoundary ? 'Converged at boundary' : (converged ? 'Converged' : 'Max iterations') };
    },
    
    tau2DL: (cs, ts, maxIter = 30) => {
        const m = cs.length, n = ts.length;
        const df = m - n + 1;
        
        if (df <= 0) return { tau2: 0, converged: true, iterations: 0, message: 'df ≤ 0' };
        
        let tau2 = 0;
        let converged = false;
        
        for (let iter = 0; iter < maxIter; iter++) {
            const est = Engine.estimate(cs, ts, tau2);
            if (!est) return { tau2: Math.max(0, tau2), converged: false, iterations: iter + 1, message: 'Estimation failed' };
            
            const W = cs.map(c => 1 / (c.se * c.se + tau2));
            const H = Engine.matMul(est.B, Engine.matMul(est.V, Engine.transpose(est.B)));
            for (let i = 0; i < H.length; i++) {
                for (let j = 0; j < H[0].length; j++) {
                    H[i][j] *= Math.sqrt(W[i] * W[j]);
                }
            }
            
            const WH = Engine.matMul(H, Engine.diagMat(W));
            const denom = W.reduce((a, b) => a + b, 0) - Engine.trace(WH);
            
            if (denom <= 0) break;
            
            const newTau2 = Math.max(0, (est.Q - df) / denom);
            
            if (Math.abs(newTau2 - tau2) < TOLERANCE.CONVERGENCE) {
                tau2 = newTau2;
                converged = true;
                break;
            }
            
            tau2 = newTau2;
        }
        
        return { tau2: Math.max(0, tau2), converged, iterations: maxIter, message: converged ? 'Converged' : 'Max iterations' };
    },
    
    tau2PM: (cs, ts, maxIter = 100) => {
        const m = cs.length, n = ts.length;
        const df = m - n + 1;
        
        if (df <= 0) return { tau2: 0, converged: true, iterations: 0, message: 'df ≤ 0' };
        
        let tau2 = 0;
        let converged = false;
        
        for (let iter = 0; iter < maxIter; iter++) {
            const est = Engine.estimate(cs, ts, tau2);
            if (!est) return { tau2: Math.max(0, tau2), converged: false, iterations: iter + 1, message: 'Estimation failed' };
            
            if (est.Q <= df) {
                tau2 = 0;
                converged = true;
                break;
            }
            
            const eps = Math.max(TOLERANCE.PM_STEP, tau2 * 0.001);
            const est2 = Engine.estimate(cs, ts, tau2 + eps);
            if (!est2) break;

            const fprime = (est2.Q - est.Q) / eps;
            if (Math.abs(fprime) < TOLERANCE.SINGULAR) break;

            const newTau2 = Math.max(0, tau2 - (est.Q - df) / fprime);

            if (Math.abs(newTau2 - tau2) < TOLERANCE.PM_STEP) {
                tau2 = newTau2;
                converged = true;
                break;
            }
            
            tau2 = newTau2;
        }
        
        return { tau2: Math.max(0, tau2), converged, iterations: maxIter, message: converged ? 'Converged' : 'Max iterations' };
    },
    
    computeTau2: (cs, ts, method = 'reml') => {
        switch (method) {
            case 'reml': return Engine.tau2REML(cs, ts);
            case 'dl': return Engine.tau2DL(cs, ts);
            case 'pm': return Engine.tau2PM(cs, ts);
            default: return Engine.tau2REML(cs, ts);
        }
    },
    
    I2: (Q, df) => {
        if (df <= 0 || Q <= 0) return 0;
        return Math.min(100, Math.max(0, 100 * (Q - df) / Q));
    },
    
    pairwise: (theta, V, ts, metric, tau2 = 0, df = null, useHKSJ = false) => {
        const n = ts.length;
        const isRatio = ['OR', 'RR'].includes(metric);
        const results = [];
        const crit = useHKSJ && df && df > 0 ? Engine.qt(0.975, df) : 1.96;
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    const es = theta[i] - theta[j];
                    const varDiff = V[i][i] + V[j][j] - 2 * V[i][j];
                    const se = varDiff > 0 ? Math.sqrt(varDiff) : 0;
                    
                    let z, pv;
                    if (se > TOLERANCE.SINGULAR) {
                        z = es / se;
                        pv = 2 * (1 - Engine.pnorm(Math.abs(z)));
                    } else {
                        z = es !== 0 ? (es > 0 ? Infinity : -Infinity) : 0;
                        pv = es !== 0 ? 0 : 1;
                    }
                    
                    const predSE = Math.sqrt(se * se + tau2);
                    const predLo = es - crit * predSE;
                    const predHi = es + crit * predSE;
                    
                    results.push({
                        t1: ts[i], t2: ts[j], es, se,
                        lo: es - crit * se, hi: es + crit * se,
                        d: isRatio ? Math.exp(es) : es,
                        dL: isRatio ? Math.exp(es - crit * se) : es - crit * se,
                        dH: isRatio ? Math.exp(es + crit * se) : es + crit * se,
                        predLo: isRatio ? Math.exp(predLo) : predLo,
                        predHi: isRatio ? Math.exp(predHi) : predHi,
                        z, pv, sig: pv < 0.05, crit, seWarning: se < TOLERANCE.SINGULAR
                    });
                }
            }
        }
        
        return results;
    },
    
    pScores: (theta, V, smallBetter) => {
        const n = theta.length;
        return theta.map((_, i) => {
            let score = 0;
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    const d = theta[i] - theta[j];
                    const varDiff = V[i][i] + V[j][j] - 2 * V[i][j];
                    const se = varDiff > 0 ? Math.sqrt(varDiff) : 0;
                    let p = se > TOLERANCE.SINGULAR ? Engine.pnorm(d / se) : (d > 0 ? 1 : (d < 0 ? 0 : 0.5));
                    if (smallBetter) p = 1 - p;
                    score += p;
                }
            }
            return score / (n - 1);
        });
    },
    
    networkDiagnostics: (cs, ts) => {
        const n = ts.length;
        const adj = {};
        ts.forEach(t => adj[t] = new Set());
        cs.forEach(c => { adj[c.t1].add(c.t2); adj[c.t2].add(c.t1); });
        
        const degrees = ts.map(t => adj[t].size);
        const avgDeg = degrees.reduce((a, b) => a + b, 0) / n;
        const maxEdges = n * (n - 1) / 2;
        const actualEdges = Engine.directComparisons(cs).length;
        const density = maxEdges > 0 ? actualEdges / maxEdges : 0;
        
        const artPts = [];
        const visited = new Set();
        const disc = {}, low = {}, parent = {};
        let time = 0;
        
        const dfs = (u) => {
            let children = 0;
            visited.add(u);
            disc[u] = low[u] = time++;
            
            for (const v of adj[u]) {
                if (!visited.has(v)) {
                    children++;
                    parent[v] = u;
                    dfs(v);
                    low[u] = Math.min(low[u], low[v]);
                    if ((parent[u] === undefined && children > 1) || (parent[u] !== undefined && low[v] >= disc[u])) {
                        if (!artPts.includes(u)) artPts.push(u);
                    }
                } else if (v !== parent[u]) {
                    low[u] = Math.min(low[u], disc[v]);
                }
            }
        };
        
        if (ts.length > 0) dfs(ts[0]);
        return { degrees, avgDegree: avgDeg, density, articulationPoints: artPts };
    },
    
    consistencyTest: (cs, ts, tau2) => {
        const m = cs.length, n = ts.length;
        const designMap = {};
        cs.forEach(c => {
            if (!designMap[c.study]) designMap[c.study] = new Set();
            designMap[c.study].add(c.t1);
            designMap[c.study].add(c.t2);
        });
        
        const designs = {};
        cs.forEach(c => {
            const key = Array.from(designMap[c.study]).sort().join('|');
            if (!designs[key]) designs[key] = [];
            designs[key].push(c);
        });
        
        const designKeys = Object.keys(designs);
        let Qwithin = 0, dfWithin = 0;
        
        designKeys.forEach(key => {
            const dc = designs[key];
            if (dc.length > 1) {
                const dt = Array.from(new Set([...dc.map(c => c.t1), ...dc.map(c => c.t2)])).sort();
                const est = Engine.estimate(dc, dt, tau2);
                if (est) { Qwithin += est.Q; dfWithin += dc.length - dt.length + 1; }
            }
        });
        
        const fullEst = Engine.estimate(cs, ts, tau2);
        if (!fullEst) return null;
        
        const Qtotal = fullEst.Q;
        const dfTotal = m - n + 1;
        const Qbetween = Qtotal - Qwithin;
        const dfBetween = dfTotal - dfWithin;
        const dfWarning = dfBetween < 0;
        const safeDfBetween = Math.max(0, dfBetween);
        
        return {
            Qtotal, dfTotal, pTotal: dfTotal > 0 ? 1 - Engine.pchisq(Qtotal, dfTotal) : 1,
            Qwithin, dfWithin, pWithin: dfWithin > 0 ? 1 - Engine.pchisq(Qwithin, dfWithin) : 1,
            Qbetween: Math.max(0, Qbetween), dfBetween: safeDfBetween,
            pBetween: safeDfBetween > 0 ? 1 - Engine.pchisq(Math.max(0, Qbetween), safeDfBetween) : 1,
            nDesigns: designKeys.length,
            inconsistent: safeDfBetween > 0 && (1 - Engine.pchisq(Math.max(0, Qbetween), safeDfBetween)) < 0.10,
            dfWarning, warningMessage: dfWarning ? 'Negative df - possible model misspecification' : null
        };
    },
    
    nodeSplit: (cs, ts, t1, t2, tau2) => {
        const direct = cs.filter(c => (c.t1 === t1 && c.t2 === t2) || (c.t1 === t2 && c.t2 === t1));
        if (!direct.length) return null;
        
        let sumW = 0, sumWY = 0;
        direct.forEach(c => {
            const w = 1 / (c.se * c.se + tau2);
            const es = c.t1 === t1 ? c.es : -c.es;
            sumW += w;
            sumWY += w * es;
        });
        
        const directES = sumWY / sumW;
        const directSE = Math.sqrt(1 / sumW);
        
        const indirect = cs.filter(c => !((c.t1 === t1 && c.t2 === t2) || (c.t1 === t2 && c.t2 === t1)));
        if (!indirect.length) return null;
        
        const indirectT = Array.from(new Set([...indirect.map(c => c.t1), ...indirect.map(c => c.t2)])).sort();
        if (!indirectT.includes(t1) || !indirectT.includes(t2)) return null;
        if (!Engine.isConnected(indirect, indirectT)) return null;
        
        const result = Engine.estimate(indirect, indirectT, tau2);
        if (!result) return null;
        
        const i1 = indirectT.indexOf(t1);
        const i2 = indirectT.indexOf(t2);
        const indirectES = result.theta[i1] - result.theta[i2];
        const varDiff = result.V[i1][i1] + result.V[i2][i2] - 2 * result.V[i1][i2];
        const indirectSE = varDiff > 0 ? Math.sqrt(varDiff) : 0;
        
        const diff = directES - indirectES;
        const diffSE = Math.sqrt(directSE * directSE + indirectSE * indirectSE);
        const z = diffSE > TOLERANCE.SINGULAR ? diff / diffSE : 0;
        const pv = 2 * (1 - Engine.pnorm(Math.abs(z)));
        
        return { t1, t2, direct: { es: directES, se: directSE, n: direct.length }, indirect: { es: indirectES, se: indirectSE }, diff, diffSE, z, pv, inconsistent: pv < 0.05 };
    },
    
    isConnected: (cs, ts) => {
        if (ts.length <= 1) return true;
        const adj = {};
        ts.forEach(t => adj[t] = new Set());
        cs.forEach(c => { adj[c.t1].add(c.t2); adj[c.t2].add(c.t1); });
        const visited = new Set([ts[0]]);
        const queue = [ts[0]];
        while (queue.length) {
            const node = queue.shift();
            adj[node].forEach(nb => {
                if (!visited.has(nb)) { visited.add(nb); queue.push(nb); }
            });
        }
        return visited.size === ts.length;
    },
    
    directComparisons: (cs) => {
        const seen = new Set();
        const comps = [];
        cs.forEach(c => {
            const key = [c.t1, c.t2].sort().join('|');
            if (!seen.has(key)) { seen.add(key); comps.push({ t1: c.t1, t2: c.t2 }); }
        });
        return comps;
    },
    
    edgeWeights: (cs) => {
        const w = {};
        cs.forEach(c => {
            const key = [c.t1, c.t2].sort().join('|');
            w[key] = (w[key] || 0) + 1;
        });
        return w;
    },
    
    // ========== NEW: High-Impact NMA Additions ==========
    
    // ========== 1. Contribution Matrix (Papakonstantinou et al. 2018) ==========
    // Computes % contribution of each direct comparison to every NMA estimate
    // NOTE: This is a simplified approximation using the hat matrix.
    // The full Papakonstantinou method uses path/stream decomposition for exact contributions.
    // This approximation is reasonable for most networks but may differ for complex topologies.
    contributionMatrix: (cs, ts, tau2 = 0) => {
        const m = cs.length, n = ts.length;
        if (m === 0 || n < 2) return null;
        
        const B = Engine.buildB(cs, ts);
        const W = cs.map(c => 1 / (c.se * c.se + tau2));
        const L = Engine.buildL(B, W);
        const Lp = Engine.pinv(L);
        if (!Lp) return null;
        
        // H = B * L+ * B' is the hat matrix (before weighting)
        const BLp = Engine.matMul(B, Lp);
        const H = Engine.matMul(BLp, Engine.transpose(B));
        
        // Weight the hat matrix: H_w[i,j] = sqrt(W[i]) * H[i,j] * sqrt(W[j])
        const Hw = Engine.zeros(m, m);
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < m; j++) {
                Hw[i][j] = Math.sqrt(W[i]) * H[i][j] * Math.sqrt(W[j]);
            }
        }
        
        // Direct evidence proportion = diagonal of H (own contribution)
        const directProp = Engine.diag(Hw);
        
        // Build contribution matrix for each pairwise comparison
        // For each NMA estimate (t_i vs t_j), compute contribution from each study
        const contributions = {};
        const pairKeys = [];
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    const key = `${ts[i]}|${ts[j]}`;
                    pairKeys.push({ t1: ts[i], t2: ts[j], key });
                    
                    // Contribution from each study to this comparison
                    const studyContrib = [];
                    let totalContrib = 0;
                    
                    for (let k = 0; k < m; k++) {
                        // Flow from study k to comparison (i,j)
                        // Uses hat matrix row corresponding to (i-j) difference
                        const contrib = Math.abs(BLp[k][i] - BLp[k][j]) * Math.sqrt(W[k]);
                        studyContrib.push({
                            study: cs[k].study,
                            t1: cs[k].t1,
                            t2: cs[k].t2,
                            contrib: contrib
                        });
                        totalContrib += contrib;
                    }
                    
                    // Normalize to percentages
                    if (totalContrib > 0) {
                        studyContrib.forEach(s => {
                            s.pct = (s.contrib / totalContrib) * 100;
                        });
                    }
                    
                    // Sort by contribution
                    studyContrib.sort((a, b) => b.pct - a.pct);
                    contributions[key] = studyContrib;
                }
            }
        }
        
        // Compute overall direct vs indirect proportion for each comparison
        const directIndirect = {};
        for (const pk of pairKeys) {
            const contribs = contributions[pk.key];
            let directSum = 0, indirectSum = 0;
            
            contribs.forEach(c => {
                const isDirect = (c.t1 === pk.t1 && c.t2 === pk.t2) || 
                                (c.t1 === pk.t2 && c.t2 === pk.t1);
                if (isDirect) directSum += c.pct;
                else indirectSum += c.pct;
            });
            
            directIndirect[pk.key] = {
                direct: directSum,
                indirect: indirectSum,
                ratio: directSum / (directSum + indirectSum) || 0
            };
        }
        
        return { 
            H: Hw, 
            directProp, 
            contributions, 
            directIndirect,
            pairKeys 
        };
    },
    
    // ========== 2. Q-Profile CI for τ² (Viechtbauer 2007) ==========
    // Gold standard confidence interval for heterogeneity
    tau2CI_QProfile: (cs, ts, tau2, alpha = 0.05) => {
        const m = cs.length, n = ts.length;
        const df = m - n + 1;
        
        if (df <= 0) return { lower: 0, upper: Infinity, df, method: 'Q-profile' };
        
        // Chi-squared quantiles
        const qLower = Engine.qchisq(alpha / 2, df);
        const qUpper = Engine.qchisq(1 - alpha / 2, df);
        
        // Function to compute Q at given tau2
        const computeQ = (t2) => {
            const est = Engine.estimate(cs, ts, Math.max(0, t2));
            return est ? est.Q : df;  // Return df if estimation fails
        };
        
        // Current Q at point estimate
        const Q0 = computeQ(tau2);
        
        // Robust bisection with bracketing
        const bisect = (targetQ, lo, hi, maxIter = 100) => {
            // Ensure we have valid brackets
            let qLo = computeQ(lo);
            let qHi = computeQ(hi);
            
            // Q decreases as tau2 increases, so qLo > qHi typically
            for (let i = 0; i < maxIter; i++) {
                const mid = (lo + hi) / 2;
                const qMid = computeQ(mid);
                
                if (Math.abs(qMid - targetQ) < 0.0001 || Math.abs(hi - lo) < 1e-8) {
                    return mid;
                }
                
                // Q decreases with increasing tau2
                if (qMid > targetQ) {
                    lo = mid;
                } else {
                    hi = mid;
                }
            }
            return (lo + hi) / 2;
        };
        
        // Lower bound of τ² CI: where Q = qUpper (large Q → small τ²)
        // If Q at τ²=0 is less than qUpper, lower bound is 0
        let tau2Lower = 0;
        const Q_at_zero = computeQ(0);
        if (Q_at_zero > qUpper) {
            // Need to find τ² where Q drops to qUpper
            // Search between 0 and a reasonable upper bound
            const searchHi = Math.max(tau2 * 50, Q_at_zero / df, 1);
            tau2Lower = bisect(qUpper, 0, searchHi);
        }
        
        // Upper bound of τ² CI: where Q = qLower (small Q → large τ²)
        let tau2Upper = Infinity;
        if (Q0 > qLower) {
            // Q can still decrease; find where it reaches qLower
            // Start search from current tau2
            let searchHi = Math.max(tau2 * 100, 10);
            
            // Expand search range if needed
            while (computeQ(searchHi) > qLower && searchHi < 1e6) {
                searchHi *= 2;
            }
            
            if (computeQ(searchHi) <= qLower) {
                tau2Upper = bisect(qLower, tau2, searchHi);
            }
            // If still can't find it, upper bound is truly very large/infinite
        }
        
        return { 
            lower: Math.max(0, tau2Lower), 
            upper: tau2Upper, 
            df, 
            Q: Q0,
            qLower,
            qUpper,
            method: 'Q-profile' 
        };
    },
    
    // Chi-squared quantile function (inverse CDF)
    qchisq: (p, df) => {
        if (p <= 0) return 0;
        if (p >= 1) return Infinity;
        if (df <= 0) return 0;
        
        // Newton-Raphson approximation
        // Initial guess using Wilson-Hilferty approximation
        let x = df * Math.pow(1 - 2/(9*df) + Engine.qnorm(p) * Math.sqrt(2/(9*df)), 3);
        
        // For small df, Wilson-Hilferty can give negative/poor initial guess
        if (df <= 2 || x <= 0) {
            // Use simpler initial guess for small df
            x = Math.max(0.001, df * p);
        } else {
            x = Math.max(0.001, Math.abs(x));
        }
        
        for (let i = 0; i < 30; i++) {
            const cdf = Engine.pchisq(x, df);
            const pdf = Engine.dchisq(x, df);
            if (Math.abs(pdf) < 1e-14) break;
            const delta = (cdf - p) / pdf;
            x = Math.max(0.001, x - delta);
            if (Math.abs(delta) < 1e-8) break;
        }
        
        return x;
    },
    
    // Chi-squared PDF
    dchisq: (x, df) => {
        if (x <= 0 || df <= 0) return 0;
        const k = df / 2;
        return Math.pow(x, k - 1) * Math.exp(-x / 2) / (Math.pow(2, k) * Engine.gamma(k));
    },
    
    // ========== 3. Comparison-Adjusted Funnel Plot (Chaimani et al. 2013) ==========
    // Correct funnel plot for NMA - standard funnel plots don't work
    comparisonAdjustedFunnel: (cs, ts, tau2 = 0, treatmentOrder = null) => {
        // If no treatment order specified, use alphabetical with reference last
        if (!treatmentOrder) {
            treatmentOrder = [...ts].sort();
        }
        
        // Get NMA estimates
        const est = Engine.estimate(cs, ts, tau2);
        if (!est) return null;
        
        // Build lookup for pooled estimates
        const pooledLookup = {};
        for (let i = 0; i < ts.length; i++) {
            for (let j = 0; j < ts.length; j++) {
                if (i !== j) {
                    pooledLookup[`${ts[i]}|${ts[j]}`] = est.theta[i] - est.theta[j];
                }
            }
        }
        
        // For each study, compute centered residual
        const points = cs.map((c, idx) => {
            // Get pooled estimate for this comparison
            const pooled = pooledLookup[`${c.t1}|${c.t2}`] || 0;
            
            // Determine sign based on treatment ordering
            const idx1 = treatmentOrder.indexOf(c.t1);
            const idx2 = treatmentOrder.indexOf(c.t2);
            const sign = idx1 < idx2 ? 1 : -1;
            
            // Centered effect = sign * (observed - pooled)
            const centered = sign * (c.es - pooled);
            
            return {
                x: centered,
                y: c.se,
                study: c.study,
                comparison: `${c.t1} vs ${c.t2}`,
                observed: c.es,
                pooled: pooled,
                residual: c.es - pooled
            };
        });
        
        // Compute Egger's test on centered effects
        const eggerTest = Engine.eggerTest(points);
        
        return {
            points,
            treatmentOrder,
            eggerTest,
            method: 'comparison-adjusted'
        };
    },
    
    // Egger's regression test for funnel asymmetry
    eggerTest: (points) => {
        if (points.length < 3) return { intercept: 0, se: 0, t: 0, p: 1, significant: false };
        
        // Regress (ES/SE) on (1/SE)
        // Equivalent to weighted regression of ES on SE with weights 1/SE²
        const n = points.length;
        let sumX = 0, sumY = 0, sumXX = 0, sumXY = 0;
        
        points.forEach(pt => {
            const x = 1 / pt.y;  // precision
            const y = pt.x / pt.y;  // standardized effect
            sumX += x;
            sumY += y;
            sumXX += x * x;
            sumXY += x * y;
        });
        
        const meanX = sumX / n;
        const meanY = sumY / n;
        const sxx = sumXX - n * meanX * meanX;
        
        if (Math.abs(sxx) < 1e-10) {
            return { intercept: 0, se: 0, t: 0, p: 1, significant: false };
        }
        
        const slope = (sumXY - n * meanX * meanY) / sxx;
        const intercept = meanY - slope * meanX;
        
        // SE of intercept using proper formula
        let ssRes = 0;
        points.forEach(pt => {
            const x = 1 / pt.y;
            const y = pt.x / pt.y;
            const pred = intercept + slope * x;
            ssRes += (y - pred) * (y - pred);
        });
        
        const df = n - 2;
        const mse = df > 0 ? ssRes / df : 0;
        const seIntercept = Math.sqrt(mse * (1/n + meanX * meanX / sxx));
        
        const t = seIntercept > 1e-10 ? intercept / seIntercept : 0;
        
        // Proper t-distribution p-value using beta function approximation
        const p = df > 0 ? Engine.pt(Math.abs(t), df) * 2 : 1;
        
        return {
            intercept,
            se: seIntercept,
            t,
            df,
            p: Math.min(1, p),
            significant: p < 0.1  // Traditional threshold for Egger's test
        };
    },
    
    // T-distribution CDF (two-tailed probability in upper tail)
    pt: (t, df) => {
        if (df <= 0) return 0.5;
        // Use regularized incomplete beta function relationship
        // P(T > t) = 0.5 * I_{df/(df+t²)}(df/2, 1/2) for t > 0
        const x = df / (df + t * t);
        return 0.5 * Engine.betaInc(x, df / 2, 0.5);
    },
    
    // Regularized incomplete beta function I_x(a,b)
    betaInc: (x, a, b) => {
        if (x <= 0) return 0;
        if (x >= 1) return 1;
        
        // Use continued fraction expansion for numerical stability
        const bt = Math.exp(
            Engine.lnGamma(a + b) - Engine.lnGamma(a) - Engine.lnGamma(b) +
            a * Math.log(x) + b * Math.log(1 - x)
        );
        
        // Use symmetry for better convergence
        if (x < (a + 1) / (a + b + 2)) {
            return bt * Engine.betaCF(x, a, b) / a;
        } else {
            return 1 - bt * Engine.betaCF(1 - x, b, a) / b;
        }
    },
    
    // Continued fraction for incomplete beta
    betaCF: (x, a, b) => {
        const maxIter = 100;
        const eps = 1e-10;
        
        let qab = a + b;
        let qap = a + 1;
        let qam = a - 1;
        let c = 1;
        let d = 1 - qab * x / qap;
        if (Math.abs(d) < eps) d = eps;
        d = 1 / d;
        let h = d;
        
        for (let m = 1; m <= maxIter; m++) {
            let m2 = 2 * m;
            let aa = m * (b - m) * x / ((qam + m2) * (a + m2));
            d = 1 + aa * d;
            if (Math.abs(d) < eps) d = eps;
            c = 1 + aa / c;
            if (Math.abs(c) < eps) c = eps;
            d = 1 / d;
            h *= d * c;
            
            aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
            d = 1 + aa * d;
            if (Math.abs(d) < eps) d = eps;
            c = 1 + aa / c;
            if (Math.abs(c) < eps) c = eps;
            d = 1 / d;
            let del = d * c;
            h *= del;
            
            if (Math.abs(del - 1) < eps) break;
        }
        return h;
    },
    
    // Log gamma function (Lanczos approximation)
    lnGamma: (z) => {
        const g = 7;
        const c = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
                   771.32342877765313, -176.61502916214059, 12.507343278686905,
                   -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        
        if (z < 0.5) {
            return Math.log(Math.PI / Math.sin(Math.PI * z)) - Engine.lnGamma(1 - z);
        }
        
        z -= 1;
        let x = c[0];
        for (let i = 1; i < g + 2; i++) {
            x += c[i] / (z + i);
        }
        let t = z + g + 0.5;
        return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
    },
    
    // ========== 4. CINeMA-Style Confidence Rating ==========
    // Semi-automatic 6-domain framework (Nikolakopoulou et al. 2020)
    cinemaRating: (cs, ts, tau2, pairwiseResults, consistencyResults, robInput = null) => {
        const ratings = {};
        const n = ts.length;
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i === j) continue;
                
                const key = `${ts[i]}|${ts[j]}`;
                const pw = pairwiseResults.find(p => p.t1 === ts[i] && p.t2 === ts[j]);
                if (!pw) continue;
                
                const domains = {
                    // 1. Within-study bias (from ROB input if available)
                    withinStudyBias: 'not assessed',
                    
                    // 2. Reporting bias (from funnel plot)
                    reportingBias: 'not assessed',
                    
                    // 3. Indirectness (requires user input)
                    indirectness: 'not assessed',
                    
                    // 4. Imprecision (from CI width and clinical threshold)
                    imprecision: Engine.assessImprecision(pw),
                    
                    // 5. Heterogeneity (from τ² and I²)
                    heterogeneity: Engine.assessHeterogeneity(tau2, cs),
                    
                    // 6. Incoherence (from consistency tests)
                    incoherence: consistencyResults ? 
                        (consistencyResults.inconsistent ? 'major concerns' : 'no concerns') : 
                        'not assessed'
                };
                
                // Assess ROB if provided
                if (robInput) {
                    const relevantStudies = cs.filter(c => 
                        (c.t1 === ts[i] && c.t2 === ts[j]) || 
                        (c.t1 === ts[j] && c.t2 === ts[i])
                    );
                    const highRob = relevantStudies.filter(s => s.rob === 'high').length;
                    const someRob = relevantStudies.filter(s => s.rob === 'some').length;
                    const total = relevantStudies.length;
                    
                    if (total > 0) {
                        const highPct = highRob / total;
                        if (highPct > 0.5) domains.withinStudyBias = 'major concerns';
                        else if (highPct > 0.2 || someRob / total > 0.5) domains.withinStudyBias = 'some concerns';
                        else domains.withinStudyBias = 'no concerns';
                    }
                }
                
                // Overall confidence level
                const concerns = Object.values(domains).filter(v => v !== 'not assessed');
                const majorConcerns = concerns.filter(v => v === 'major concerns').length;
                const someConcerns = concerns.filter(v => v === 'some concerns').length;
                
                let confidence;
                if (majorConcerns >= 2) confidence = 'very low';
                else if (majorConcerns === 1 || someConcerns >= 2) confidence = 'low';
                else if (someConcerns === 1) confidence = 'moderate';
                else confidence = 'high';
                
                ratings[key] = {
                    comparison: `${ts[i]} vs ${ts[j]}`,
                    domains,
                    confidence,
                    majorConcerns,
                    someConcerns
                };
            }
        }
        
        return ratings;
    },
    
    // Helper: Assess imprecision domain
    // Based on GRADE guidance: imprecision concerns when CI includes both benefit and harm
    // or when CI is very wide relative to the optimal information size
    assessImprecision: (pw, clinicalThreshold = null) => {
        const ciWidth = pw.hi - pw.lo;
        const absEffect = Math.abs(pw.es);
        
        // Check if CI crosses null (or clinical threshold if provided)
        const threshold = clinicalThreshold !== null ? clinicalThreshold : 0;
        const crossesThreshold = (pw.lo < threshold && pw.hi > threshold);
        
        // Check if CI crosses null AND includes clinically important effects
        // Standard: CI width > 2 times the point estimate suggests high imprecision
        const relativeWidth = absEffect > 0.001 ? ciWidth / absEffect : ciWidth;
        
        // GRADE criteria adapted:
        // - No concerns: Precise estimate, doesn't cross null or threshold
        // - Some concerns: Either crosses null OR wide CI (but not both)
        // - Major concerns: Crosses null AND very wide CI, suggesting high uncertainty
        
        if (!crossesThreshold) {
            // Doesn't cross threshold
            if (relativeWidth < 1.0) return 'no concerns';
            if (relativeWidth < 2.0) return 'some concerns';
            return 'major concerns';  // Very wide CI even without crossing null
        } else {
            // Crosses threshold (includes null or clinical threshold)
            if (relativeWidth < 1.5) return 'some concerns';  // Crosses but relatively precise
            return 'major concerns';  // Crosses and wide
        }
    },
    
    // Helper: Assess heterogeneity domain
    // Based on Cochrane guidance: I² thresholds of 40% and 60%
    assessHeterogeneity: (tau2, cs) => {
        // Compute I² properly from tau2 and average within-study variance
        const m = cs.length;
        const avgVar = cs.reduce((s, c) => s + c.se * c.se, 0) / m;
        const totalVar = avgVar + tau2;
        const I2 = totalVar > 0 ? (tau2 / totalVar) * 100 : 0;
        
        // Cochrane thresholds: 0-40% low, 40-60% moderate, 60%+ substantial
        // But also consider absolute tau2 value
        if (I2 < 40 && tau2 < 0.04) return 'no concerns';
        if (I2 < 60 && tau2 < 0.16) return 'some concerns';
        return 'major concerns';
    },
    
    // ========== 5. Threshold Analysis (Phillippo et al. 2018) ==========
    // How much would evidence need to change before recommendation changes?
    // NOTE: This is a simplified linear approximation. Full Phillippo method uses
    // invariant intervals computed via optimization. This approximation works well
    // for first-order sensitivity but may underestimate thresholds for complex networks.
    thresholdAnalysis: (cs, ts, tau2, decisionThreshold = 0) => {
        const est = Engine.estimate(cs, ts, tau2);
        if (!est) return null;
        
        const n = ts.length;
        const m = cs.length;
        const results = [];
        
        // For each comparison, compute threshold
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                const es = est.theta[i] - est.theta[j];
                const varDiff = est.V[i][i] + est.V[j][j] - 2 * est.V[i][j];
                const se = Math.sqrt(Math.max(0, varDiff));
                
                // Distance to decision threshold (in log scale)
                const distanceToThreshold = Math.abs(es - decisionThreshold);
                
                // For each study, compute influence on this comparison
                const studyThresholds = cs.map((c, k) => {
                    // Compute partial derivative: ∂(theta_i - theta_j)/∂y_k
                    // Using the hat matrix H = B(B'WB)^+ B'W
                    // Influence = (H[k,i] - H[k,j]) for study k on comparison (i,j)
                    
                    // More accurate: use hat matrix directly
                    let influence = 0;
                    for (let p = 0; p < n; p++) {
                        const Bki = est.B[k][i];
                        const Bkj = est.B[k][j];
                        // Partial derivative through Laplacian pseudoinverse
                        influence += (est.V[i][p] * Bki - est.V[j][p] * Bki) * est.W[k];
                        influence += (est.V[i][p] * (-Bkj) - est.V[j][p] * (-Bkj)) * est.W[k];
                    }
                    
                    // Simplified influence (when above is too complex)
                    // Just use direct contribution from design matrix
                    const simpleInfluence = (est.B[k][i] - est.B[k][j]) * est.W[k];
                    influence = Math.abs(simpleInfluence);
                    
                    // Threshold = distance / influence
                    // How much study ES needs to change to flip decision
                    const threshold = influence > 1e-10 ? 
                        distanceToThreshold / influence : Infinity;
                    
                    return {
                        study: c.study,
                        t1: c.t1,
                        t2: c.t2,
                        originalES: c.es,
                        influence: influence,
                        threshold: threshold,
                        // Threshold in SE units for interpretability
                        thresholdSE: c.se > 0 ? threshold / c.se : Infinity
                    };
                });
                
                // Sort by threshold (smallest = most influential)
                studyThresholds.sort((a, b) => a.threshold - b.threshold);
                
                // Robustness: minimum threshold across all studies
                const minThreshold = Math.min(...studyThresholds.map(s => s.threshold));
                const minThresholdSE = Math.min(...studyThresholds.map(s => s.thresholdSE));
                
                // Robust if requires >1.5 SE change in most influential study
                const isRobust = minThresholdSE > 1.5;
                
                results.push({
                    t1: ts[i],
                    t2: ts[j],
                    estimate: es,
                    se: se,
                    distanceToThreshold,
                    distanceInSE: se > 0 ? distanceToThreshold / se : Infinity,
                    isRobust,
                    minThreshold,
                    minThresholdSE,
                    studyThresholds: studyThresholds.slice(0, 5)  // Top 5 most influential
                });
            }
        }
        
        return {
            decisionThreshold,
            comparisons: results,
            overallRobustness: results.filter(r => r.isRobust).length / results.length
        };
    },
    
    // ========== 6. Network Meta-Regression ==========
    // Allow covariate adjustment
    estimateWithCovariates: (cs, ts, tau2 = 0, covariates = null) => {
        if (!covariates || covariates.length !== cs.length) {
            return Engine.estimate(cs, ts, tau2);
        }
        
        const m = cs.length, n = ts.length;
        const B = Engine.buildB(cs, ts);
        const W = cs.map(c => 1 / (c.se * c.se + tau2));
        
        // Number of covariates
        const p = Array.isArray(covariates[0]) ? covariates[0].length : 1;
        
        // Build extended design matrix [B | X]
        const X = Engine.zeros(m, n + p);
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                X[i][j] = B[i][j];
            }
            // Add covariates
            const cov = Array.isArray(covariates[i]) ? covariates[i] : [covariates[i]];
            for (let k = 0; k < p; k++) {
                X[i][n + k] = cov[k] || 0;
            }
        }
        
        // Weighted least squares: (X'WX)^(-1) X'Wy
        const XtW = Engine.zeros(n + p, m);
        for (let i = 0; i < n + p; i++) {
            for (let j = 0; j < m; j++) {
                XtW[i][j] = X[j][i] * W[j];
            }
        }
        
        const XtWX = Engine.matMul(XtW, X);
        const XtWXinv = Engine.pinv(XtWX);
        if (!XtWXinv) return null;
        
        const y = cs.map(c => c.es);
        const XtWy = XtW.map(row => row.reduce((s, v, j) => s + v * y[j], 0));
        const beta = Engine.matVec(XtWXinv, XtWy);
        
        // Split into treatment effects and covariate effects
        const theta = beta.slice(0, n);
        const gamma = beta.slice(n);
        
        // Fitted values
        const yhat = X.map(row => row.reduce((s, v, j) => s + v * beta[j], 0));
        
        // Q statistic
        const Q = y.reduce((s, yi, i) => s + W[i] * Math.pow(yi - yhat[i], 2), 0);
        
        // R² (proportion of heterogeneity explained)
        const estBase = Engine.estimate(cs, ts, tau2);
        const R2 = estBase ? Math.max(0, 1 - Q / estBase.Q) : 0;
        
        return {
            theta,
            gamma,
            V: XtWXinv,
            Q,
            R2,
            covariateNames: covariates.names || gamma.map((_, i) => `Covariate ${i + 1}`)
        };
    },
    
    // ========== 7. SUCRA (alongside P-scores) ==========
    // Surface Under Cumulative Ranking curve
    SUCRA: (theta, V, smallBetter) => {
        const n = theta.length;
        const pscores = Engine.pScores(theta, V, smallBetter);
        
        // Compute rank probabilities via simulation with proper covariance
        const nSim = 2000;
        const rankCounts = Array(n).fill(null).map(() => Array(n).fill(0));
        
        // Cholesky decomposition of V for correlated sampling
        const L = Engine.cholesky(V);
        
        for (let sim = 0; sim < nSim; sim++) {
            // Generate independent standard normals
            const z = Array(n).fill(0).map(() => Engine.rnorm());
            
            // Transform to multivariate normal: samples = theta + L * z
            const samples = theta.map((t, i) => {
                let sum = t;
                for (let j = 0; j <= i; j++) {
                    sum += L[i][j] * z[j];
                }
                return sum;
            });
            
            // Rank (0 = best)
            const indexed = samples.map((s, i) => ({ i, s }));
            indexed.sort((a, b) => smallBetter ? a.s - b.s : b.s - a.s);
            indexed.forEach((item, rank) => rankCounts[item.i][rank]++);
        }
        
        // Compute cumulative rank probabilities and SUCRA
        // SUCRA = (1/(n-1)) * sum_{r=1}^{n-1} P(rank <= r)
        const sucra = rankCounts.map((counts) => {
            const probs = counts.map(c => c / nSim);
            let cumSum = 0;
            let sucraSum = 0;
            for (let r = 0; r < n - 1; r++) {
                cumSum += probs[r];  // P(rank <= r)
                sucraSum += cumSum;
            }
            return sucraSum / (n - 1);
        });
        
        return {
            pscores,
            sucra,
            rankProbabilities: rankCounts.map(c => c.map(v => v / nSim)),
            agreement: pscores.map((p, i) => Math.abs(p - sucra[i]) < 0.05).every(v => v)
        };
    },
    
    // Cholesky decomposition (returns lower triangular L where V = L * L')
    cholesky: (A) => {
        const n = A.length;
        const L = Engine.zeros(n, n);
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j <= i; j++) {
                let sum = A[i][j];
                for (let k = 0; k < j; k++) {
                    sum -= L[i][k] * L[j][k];
                }
                if (i === j) {
                    // Diagonal: handle near-zero or negative (numerical issues)
                    L[i][j] = sum > TOLERANCE.CHOLESKY ? Math.sqrt(sum) : TOLERANCE.CHOLESKY;
                } else {
                    L[i][j] = L[j][j] > TOLERANCE.CHOLESKY ? sum / L[j][j] : 0;
                }
            }
        }
        return L;
    },
    
    // Standard normal random number (Box-Muller)
    rnorm: () => {
        let u1 = Math.random(), u2 = Math.random();
        while (u1 === 0) u1 = Math.random();
        return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    },
    
    // ========== 8. League Table with Contribution Shading ==========
    leagueTableWithContributions: (ts, pairwise, contributions) => {
        const n = ts.length;
        const table = Engine.zeros(n, n);
        const shading = Engine.zeros(n, n);  // 0-1 for direct proportion
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i === j) {
                    table[i][j] = null;
                    shading[i][j] = null;
                } else {
                    const pw = pairwise.find(p => p.t1 === ts[i] && p.t2 === ts[j]);
                    table[i][j] = pw ? {
                        es: pw.d,
                        lo: pw.dL,
                        hi: pw.dH,
                        sig: pw.sig
                    } : null;
                    
                    // Shading based on direct evidence proportion
                    const key = `${ts[i]}|${ts[j]}`;
                    if (contributions && contributions.directIndirect && contributions.directIndirect[key]) {
                        shading[i][j] = contributions.directIndirect[key].ratio;
                    } else {
                        shading[i][j] = 0;
                    }
                }
            }
        }
        
        return { table, shading, treatments: ts };
    },
    
    // ========== 9. Study Importance (Rücker et al. 2020) ==========
    // Variance reduction when adding each study (0-1, 1=essential)
    // Optimized version with connectivity caching
    studyImportance: (cs, ts, tau2 = 0) => {
        const fullEst = Engine.estimate(cs, ts, tau2);
        if (!fullEst) return null;
        
        const n = cs.length;
        const importance = [];
        
        // Pre-compute pairwise variance lookup for all comparisons
        const fullVarLookup = {};
        for (let i = 0; i < ts.length; i++) {
            for (let j = i + 1; j < ts.length; j++) {
                const varDiff = fullEst.V[i][i] + fullEst.V[j][j] - 2 * fullEst.V[i][j];
                fullVarLookup[`${ts[i]}|${ts[j]}`] = varDiff;
            }
        }
        
        for (let idx = 0; idx < n; idx++) {
            const c = cs[idx];
            
            // Remove this study
            const reduced = cs.filter((_, i) => i !== idx);
            const reducedTs = [...new Set([...reduced.map(r => r.t1), ...reduced.map(r => r.t2)])];
            
            // Check if treatments still in network
            if (!reducedTs.includes(c.t1) || !reducedTs.includes(c.t2)) {
                // Study introduces new treatments - highly important
                importance.push({
                    study: c.study,
                    t1: c.t1,
                    t2: c.t2,
                    importance: 0.95,
                    critical: false,
                    reason: 'Introduces treatments to network'
                });
                continue;
            }
            
            // Check connectivity
            if (!Engine.isConnected(reduced, reducedTs)) {
                importance.push({
                    study: c.study,
                    t1: c.t1,
                    t2: c.t2,
                    importance: 1.0,
                    critical: true,
                    reason: 'Network disconnects without this study'
                });
                continue;
            }
            
            // Re-estimate without this study
            const reducedEst = Engine.estimate(reduced, reducedTs, tau2);
            if (!reducedEst) {
                importance.push({
                    study: c.study,
                    t1: c.t1,
                    t2: c.t2,
                    importance: 0.9,
                    critical: false,
                    reason: 'Estimation fails without this study'
                });
                continue;
            }
            
            // Compute variance change for the direct comparison
            const key = [c.t1, c.t2].sort().join('|');
            const i1 = ts.indexOf(c.t1);
            const i2 = ts.indexOf(c.t2);
            const ri1 = reducedTs.indexOf(c.t1);
            const ri2 = reducedTs.indexOf(c.t2);
            
            if (ri1 < 0 || ri2 < 0 || i1 < 0 || i2 < 0) {
                importance.push({
                    study: c.study,
                    t1: c.t1,
                    t2: c.t2,
                    importance: 0.5,
                    critical: false,
                    reason: 'Index mismatch'
                });
                continue;
            }
            
            const fullVar = fullVarLookup[key] || 
                (fullEst.V[i1][i1] + fullEst.V[i2][i2] - 2 * fullEst.V[i1][i2]);
            const reducedVar = reducedEst.V[ri1][ri1] + reducedEst.V[ri2][ri2] - 
                2 * reducedEst.V[ri1][ri2];
            
            // Importance = relative variance increase
            // If variance doubles when removed, importance = 0.5
            // If variance goes to infinity, importance = 1.0
            const varRatio = reducedVar / fullVar;
            const imp = Math.min(1, Math.max(0, 1 - 1 / varRatio));
            
            importance.push({
                study: c.study,
                t1: c.t1,
                t2: c.t2,
                importance: imp,
                varianceIncrease: varRatio - 1,
                varianceIncreasePercent: ((varRatio - 1) * 100).toFixed(1),
                critical: false,
                reason: varRatio > 2 ? 'High variance increase' : 'Moderate contribution'
            });
        }
        
        // Sort by importance (descending)
        importance.sort((a, b) => b.importance - a.importance);
        
        return importance;
    }
};

// ============================================================================
// Validation Module
// ============================================================================

const Validation = {
    tests: [],
    
    runAll() {
        this.tests = [];
        
        // Test 1: Matrix Operations
        this.tests.push(this.testMatrixOps());
        
        // Test 2: Triangle Network
        this.tests.push(this.testTriangleNetwork());
        
        // Test 3: REML Convergence
        this.tests.push(this.testREML());
        
        // Test 4: DL Estimation
        this.tests.push(this.testDL());
        
        // Test 5: P-scores
        this.tests.push(this.testPScores());
        
        // Test 6: I² Statistic
        this.tests.push(this.testI2());
        
        // Test 7: Confidence Intervals
        this.tests.push(this.testCIs());
        
        // Test 8: R Comparison
        this.tests.push(this.testRComparison());
        
        // Test 9: Network Connectivity
        this.tests.push(this.testConnectivity());
        
        // Test 10: Numerical Stability
        this.tests.push(this.testNumericalStability());
        
        return this.tests;
    },
    
    testMatrixOps() {
        const L = [[2, -1, -1], [-1, 2, -1], [-1, -1, 2]];
        const Lp = Engine.pinv(L);
        const rowSums = Lp.map(row => row.reduce((a, b) => a + b, 0));
        const pass = rowSums.every(s => Math.abs(s) < 1e-10);
        
        return {
            name: 'Matrix Operations',
            description: 'Laplacian pseudoinverse row sums ≈ 0',
            pass,
            details: `Row sums: [${rowSums.map(s => s.toExponential(2)).join(', ')}]`
        };
    },
    
    testTriangleNetwork() {
        const contrasts = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.5, se: 0.1 },
            { study: 'S2', t1: 'B', t2: 'C', es: 0.3, se: 0.1 },
            { study: 'S3', t1: 'A', t2: 'C', es: 0.8, se: 0.1 }
        ];
        const treatments = ['A', 'B', 'C'];
        const est = Engine.estimate(contrasts, treatments, 0);
        
        const theta = est.theta;
        const aVsB = theta[0] - theta[1];
        const bVsC = theta[1] - theta[2];
        const aVsC = theta[0] - theta[2];
        const transitivityError = Math.abs((aVsB + bVsC) - aVsC);
        const pass = transitivityError < 1e-10;
        
        return {
            name: 'Triangle Network',
            description: 'Transitivity: A-B + B-C = A-C',
            pass,
            details: `Direct A-C: ${aVsC.toFixed(4)}, Indirect: ${(aVsB + bVsC).toFixed(4)}`
        };
    },
    
    testREML() {
        const contrasts = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.50, se: 0.40 },
            { study: 'S2', t1: 'A', t2: 'C', es: 0.45, se: 0.35 },
            { study: 'S3', t1: 'B', t2: 'C', es: -0.10, se: 0.30 },
            { study: 'S4', t1: 'A', t2: 'D', es: 0.80, se: 0.45 },
            { study: 'S5', t1: 'C', t2: 'D', es: 0.25, se: 0.38 }
        ];
        const treatments = ['A', 'B', 'C', 'D'];
        const result = Engine.tau2REML(contrasts, treatments);
        const pass = result.converged && result.tau2 >= 0;
        
        return {
            name: 'REML τ² Estimation',
            description: 'Converges with non-negative τ²',
            pass,
            details: `τ² = ${result.tau2.toFixed(6)}, converged: ${result.converged}`
        };
    },
    
    testDL() {
        const contrasts = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.50, se: 0.40 },
            { study: 'S2', t1: 'A', t2: 'C', es: 0.45, se: 0.35 },
            { study: 'S3', t1: 'B', t2: 'C', es: -0.10, se: 0.30 }
        ];
        const treatments = ['A', 'B', 'C'];
        const reml = Engine.tau2REML(contrasts, treatments);
        const dl = Engine.tau2DL(contrasts, treatments);
        const diff = Math.abs(reml.tau2 - dl.tau2);
        const pass = diff < 0.1 || (reml.tau2 < 0.01 && dl.tau2 < 0.01);
        
        return {
            name: 'DL τ² Estimation',
            description: 'DL ≈ REML within tolerance',
            pass,
            details: `REML: ${reml.tau2.toFixed(6)}, DL: ${dl.tau2.toFixed(6)}`
        };
    },
    
    testPScores() {
        const contrasts = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.5, se: 0.1 },
            { study: 'S2', t1: 'B', t2: 'C', es: 0.3, se: 0.1 },
            { study: 'S3', t1: 'A', t2: 'C', es: 0.8, se: 0.1 }
        ];
        const treatments = ['A', 'B', 'C'];
        const est = Engine.estimate(contrasts, treatments, 0);
        const pscores = Engine.pScores(est.theta, est.V, false);
        const sum = pscores.reduce((a, b) => a + b, 0);
        const expectedSum = treatments.length * 0.5;
        const inRange = pscores.every(p => p >= 0 && p <= 1);
        const pass = Math.abs(sum - expectedSum) < 0.01 && inRange;
        
        return {
            name: 'P-scores Calculation',
            description: 'Sum = n×0.5, all in [0,1]',
            pass,
            details: `Sum: ${sum.toFixed(4)} (expected ${expectedSum}), range OK: ${inRange}`
        };
    },
    
    testI2() {
        const cases = [
            { Q: 10, df: 5, expected: 50 },
            { Q: 5, df: 5, expected: 0 },
            { Q: 3, df: 5, expected: 0 },
            { Q: 100, df: 10, expected: 90 }
        ];
        
        const results = cases.map(c => {
            const computed = Engine.I2(c.Q, c.df);
            return Math.abs(computed - c.expected) < 0.1;
        });
        
        const pass = results.every(r => r);
        
        return {
            name: 'I² Statistic',
            description: 'Correct I² calculation',
            pass,
            details: `All ${cases.length} test cases passed: ${pass}`
        };
    },
    
    testCIs() {
        const contrasts = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.5, se: 0.1 },
            { study: 'S2', t1: 'B', t2: 'C', es: 0.3, se: 0.1 },
            { study: 'S3', t1: 'A', t2: 'C', es: 0.8, se: 0.1 }
        ];
        const treatments = ['A', 'B', 'C'];
        const est = Engine.estimate(contrasts, treatments, 0);
        const df = contrasts.length - treatments.length + 1;
        
        const wald = Engine.pairwise(est.theta, est.V, treatments, 'MD', 0, df, false);
        const hksj = Engine.pairwise(est.theta, est.V, treatments, 'MD', 0, df, true);
        
        const waldAB = wald.find(p => p.t1 === 'A' && p.t2 === 'B');
        const hksjAB = hksj.find(p => p.t1 === 'A' && p.t2 === 'B');
        
        const waldWidth = waldAB.hi - waldAB.lo;
        const hksjWidth = hksjAB.hi - hksjAB.lo;
        const pass = hksjWidth >= waldWidth - 0.001;
        
        return {
            name: 'Confidence Intervals',
            description: 'HKSJ CIs ≥ Wald CIs',
            pass,
            details: `Wald width: ${waldWidth.toFixed(3)}, HKSJ width: ${hksjWidth.toFixed(3)}`
        };
    },
    
    testRComparison() {
        const contrasts = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.50, se: 0.40 },
            { study: 'S2', t1: 'A', t2: 'C', es: 0.45, se: 0.35 },
            { study: 'S3', t1: 'B', t2: 'C', es: -0.10, se: 0.30 },
            { study: 'S4', t1: 'A', t2: 'D', es: 0.80, se: 0.45 },
            { study: 'S5', t1: 'C', t2: 'D', es: 0.25, se: 0.38 }
        ];
        const treatments = ['A', 'B', 'C', 'D'];
        const tau = Engine.tau2REML(contrasts, treatments);
        const est = Engine.estimate(contrasts, treatments, tau.tau2);
        const pscores = Engine.pScores(est.theta, est.V, false);
        const pscoreSum = pscores.reduce((a, b) => a + b, 0);
        
        // R netmeta gives: tau2≈0, Q≈0.038, pscores sum≈2.0
        const tau2Match = tau.tau2 < 0.01;
        const qMatch = Math.abs(est.Q - 0.038) < 0.01;
        const pscoreMatch = Math.abs(pscoreSum - 2.0) < 0.01;
        const pass = tau2Match && qMatch && pscoreMatch;
        
        return {
            name: 'R netmeta Comparison',
            description: 'Matches R netmeta output',
            pass,
            details: `τ²: ${tau.tau2.toFixed(4)}, Q: ${est.Q.toFixed(4)}, P-score sum: ${pscoreSum.toFixed(4)}`
        };
    },
    
    testConnectivity() {
        const connected = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.5, se: 0.1 },
            { study: 'S2', t1: 'B', t2: 'C', es: 0.3, se: 0.1 }
        ];
        const disconnected = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.5, se: 0.1 },
            { study: 'S2', t1: 'C', t2: 'D', es: 0.3, se: 0.1 }
        ];
        
        const test1 = Engine.isConnected(connected, ['A', 'B', 'C']);
        const test2 = !Engine.isConnected(disconnected, ['A', 'B', 'C', 'D']);
        const pass = test1 && test2;
        
        return {
            name: 'Network Connectivity',
            description: 'Detects connected/disconnected networks',
            pass,
            details: `Connected detected: ${test1}, Disconnected detected: ${test2}`
        };
    },
    
    testNumericalStability() {
        const smallSE = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.5, se: 0.001 },
            { study: 'S2', t1: 'B', t2: 'C', es: 0.3, se: 0.001 },
            { study: 'S3', t1: 'A', t2: 'C', es: 0.8, se: 0.001 }
        ];
        const largeSE = [
            { study: 'S1', t1: 'A', t2: 'B', es: 0.5, se: 10.0 },
            { study: 'S2', t1: 'B', t2: 'C', es: 0.3, se: 10.0 },
            { study: 'S3', t1: 'A', t2: 'C', es: 0.8, se: 10.0 }
        ];
        
        const treatments = ['A', 'B', 'C'];
        const estSmall = Engine.estimate(smallSE, treatments, 0);
        const estLarge = Engine.estimate(largeSE, treatments, 0);
        
        const smallOK = estSmall !== null && estSmall.theta.every(t => isFinite(t));
        const largeOK = estLarge !== null && estLarge.theta.every(t => isFinite(t));
        const pass = smallOK && largeOK;
        
        return {
            name: 'Numerical Stability',
            description: 'Handles extreme SE values',
            pass,
            details: `Small SE: ${smallOK ? 'OK' : 'FAIL'}, Large SE: ${largeOK ? 'OK' : 'FAIL'}`
        };
    }
};

// ============================================================================
// Application Controller
// ============================================================================

const app = {
    data: [],
    config: { metric: 'OR', reference: '', smallBetter: false, tauMethod: 'reml', ciMethod: 'z' },
    results: null,
    saveTimeout: null,
    
    init() {
        let loaded = false;
        try {
            const stored = localStorage.getItem('nma52');
            if (stored) {
                const p = JSON.parse(stored);
                if (p.data && p.data.length > 0) {
                    this.data = p.data;
                    if (p.config) this.config = { ...this.config, ...p.config };
                    loaded = true;
                }
            }
        } catch (e) {
            logError('Loading data from localStorage', e);
        }
        
        if (!loaded) { this.loadExample(); return; }
        
        this.render();
        this.updateReferenceSelect();
        this.setUIFromConfig();
        this.saveToStorage();
        this.calculate();
        this.setupEventListeners();
        this.renderValidation();
    },
    
    loadExample() {
        this.data = [
            { study: 'Study A', t1: 'Drug A', t2: 'Placebo', es: '0.35', se: '0.12', year: '2018', rob: 'low' },
            { study: 'Study B', t1: 'Drug A', t2: 'Placebo', es: '0.28', se: '0.14', year: '2019', rob: 'low' },
            { study: 'Study C', t1: 'Drug B', t2: 'Placebo', es: '0.42', se: '0.11', year: '2017', rob: 'some' },
            { study: 'Study D', t1: 'Drug B', t2: 'Placebo', es: '0.38', se: '0.15', year: '2020', rob: 'low' },
            { study: 'Study E', t1: 'Drug C', t2: 'Placebo', es: '0.55', se: '0.13', year: '2019', rob: 'high' },
            { study: 'Study F', t1: 'Drug C', t2: 'Drug A', es: '0.18', se: '0.10', year: '2021', rob: 'low' },
            { study: 'Study G', t1: 'Drug B', t2: 'Drug A', es: '0.08', se: '0.09', year: '2020', rob: 'some' },
            { study: 'Study H', t1: 'Drug C', t2: 'Drug B', es: '0.12', se: '0.11', year: '2022', rob: 'low' },
            { study: 'Study I', t1: 'Drug D', t2: 'Placebo', es: '0.48', se: '0.14', year: '2021', rob: 'some' },
            { study: 'Study J', t1: 'Drug D', t2: 'Drug C', es: '-0.06', se: '0.12', year: '2022', rob: 'low' }
        ];
        this.config.reference = 'Placebo';
        this.saveToStorage();
        this.render();
        this.updateReferenceSelect();
        this.setUIFromConfig();
        this.calculate();
        this.setupEventListeners();
        this.renderValidation();
        this.showToast('Example data loaded');
    },
    
    setupEventListeners() {
        if (this.eventListenersSetup) return;
        this.eventListenersSetup = true;

        // Input handler for data table
        this.inputHandler = () => {
            clearTimeout(this.saveTimeout);
            this.saveTimeout = setTimeout(() => { this.save(); this.calculate(); }, 400);
        };
        document.querySelector('.table-container').addEventListener('input', this.inputHandler);

        // Debounced resize handler (250ms delay)
        this.resizeHandler = debounce(() => {
            if (this.results) this.draw();
        }, 250);
        window.addEventListener('resize', this.resizeHandler);
    },
    
    clearData() { if (confirm('Clear all data?')) { this.data = []; this.save(); this.render(); this.calculate(); } },
    
    save() {
        const rows = [];
        document.querySelectorAll('#table-body tr').forEach(tr => {
            const inp = tr.querySelectorAll('input, select');
            const row = { study: inp[0]?.value || '', t1: inp[1]?.value || '', t2: inp[2]?.value || '', es: inp[3]?.value || '', se: inp[4]?.value || '', year: inp[5]?.value || '', rob: inp[6]?.value || 'low' };
            if (row.study || row.t1 || row.t2) rows.push(row);
        });
        this.data = rows;
        this.saveToStorage();
    },
    
    saveToStorage() {
        try {
            localStorage.setItem('nma52', JSON.stringify({ data: this.data, config: this.config }));
        } catch (e) {
            logError('Saving data to localStorage', e);
        }
    },
    
    exportJSON() {
        const blob = new Blob([JSON.stringify({ data: this.data, config: this.config }, null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'nma_data.json'; a.click();
        this.showToast('JSON exported');
    },
    
    exportCSV() {
        if (!this.results) { this.showToast('No results', true); return; }
        const r = this.results, ref = this.config.reference || r.treatments[0];
        let csv = 'comparison,treatment1,treatment2,TE,seTE,lower,upper,z,pval,sig\n';
        r.pairwise.filter(p => p.t2 === ref).forEach(p => {
            const comp = escapeCSV(`${p.t1} vs ${p.t2}`);
            const t1 = escapeCSV(p.t1);
            const t2 = escapeCSV(p.t2);
            csv += `${comp},${t1},${t2},${p.es.toFixed(4)},${p.se.toFixed(4)},${p.lo.toFixed(4)},${p.hi.toFixed(4)},${p.z.toFixed(4)},${p.pv.toFixed(6)},${p.sig ? 'yes' : 'no'}\n`;
        });
        csv += `\n# tau2,${r.tau2.toFixed(6)}\n# I2,${r.I2.toFixed(2)}\n# Q,${r.Q.toFixed(4)}\n# df,${r.df}\n`;
        const blob = new Blob([csv], { type: 'text/csv' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'nma_results.csv'; a.click();
        this.showToast('CSV exported');
    },
    
    importFile(input) {
        const file = input.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                if (file.name.endsWith('.csv')) { this.importCSV(e.target.result); }
                else {
                    const json = JSON.parse(e.target.result);
                    if (json.data) {
                        this.data = json.data;
                        if (json.config) this.config = { ...this.config, ...json.config };
                        this.save(); this.render(); this.updateReferenceSelect(); this.setUIFromConfig(); this.calculate();
                        this.showToast('Imported');
                    }
                }
            } catch (err) { this.showToast('Invalid file', true); }
        };
        reader.readAsText(file);
        input.value = '';
    },
    
    importCSV(content) {
        const lines = content.trim().split('\n');
        if (lines.length < 2) { this.showToast('Empty CSV', true); return; }
        const headers = lines[0].toLowerCase().split(',').map(h => h.trim().replace(/"/g, ''));
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            if (!lines[i].trim() || lines[i].startsWith('#')) continue;
            const vals = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
            const row = {};
            headers.forEach((h, j) => {
                if (h === 'study' || h === 'studlab') row.study = vals[j];
                else if (h === 't1' || h === 'treat1' || h === 'treatment1') row.t1 = vals[j];
                else if (h === 't2' || h === 'treat2' || h === 'treatment2') row.t2 = vals[j];
                else if (h === 'es' || h === 'te' || h === 'effect') row.es = vals[j];
                else if (h === 'se' || h === 'sete') row.se = vals[j];
                else if (h === 'year') row.year = vals[j];
                else if (h === 'rob') row.rob = vals[j];
            });
            if (row.t1 && row.t2 && row.es && row.se) { row.rob = row.rob || 'low'; row.study = row.study || `Study ${i}`; data.push(row); }
        }
        if (data.length > 0) { this.data = data; this.save(); this.render(); this.updateReferenceSelect(); this.calculate(); this.showToast(`Imported ${data.length} contrasts`); }
        else { this.showToast('No valid data', true); }
    },
    
    render() {
        // Table header with accessibility attributes
        document.getElementById('table-head').innerHTML = `
            <th scope="col">Study</th>
            <th scope="col">Treatment 1</th>
            <th scope="col">Treatment 2</th>
            <th scope="col">log(ES)</th>
            <th scope="col">SE</th>
            <th scope="col">Year</th>
            <th scope="col">ROB</th>
            <th scope="col" aria-label="Actions"></th>`;

        const tbody = document.getElementById('table-body');
        tbody.innerHTML = '';
        this.data.forEach((row, idx) => this.addRow(tbody, row, idx));
        // Add empty row for new entries
        this.addRow(tbody, {}, -1);
    },

    // Column configuration for input fields
    inputColumns: [
        { key: 'study', label: 'Study name', placeholder: '' },
        { key: 't1', label: 'Treatment 1', placeholder: '' },
        { key: 't2', label: 'Treatment 2', placeholder: '' },
        { key: 'es', label: 'Effect size', placeholder: '0.00' },
        { key: 'se', label: 'Standard error', placeholder: '0.10' },
        { key: 'year', label: 'Year', placeholder: '' }
    ],

    addRow(tbody, row, idx) {
        const tr = document.createElement('tr');
        const isNewRow = idx === -1;

        // Add input fields for each column
        this.inputColumns.forEach(col => {
            const td = document.createElement('td');
            const inp = document.createElement('input');
            inp.type = 'text';
            inp.value = row[col.key] || '';
            inp.placeholder = col.placeholder;
            inp.setAttribute('aria-label', col.label);

            if (isNewRow) {
                inp.onfocus = () => this.addNewRow();
            }

            td.appendChild(inp);
            tr.appendChild(td);
        });

        // ROB select
        const tdRob = document.createElement('td');
        const sel = document.createElement('select');
        sel.setAttribute('aria-label', 'Risk of Bias');
        sel.innerHTML = `
            <option value="low">Low</option>
            <option value="some">Some Concerns</option>
            <option value="high">High</option>`;
        sel.value = row.rob || 'low';

        if (isNewRow) {
            sel.onfocus = () => this.addNewRow();
        }

        tdRob.appendChild(sel);
        tr.appendChild(tdRob);

        // Delete button
        const tdDel = document.createElement('td');
        if (!isNewRow) {
            const del = document.createElement('span');
            del.className = 'delete-btn';
            del.textContent = '×';
            del.setAttribute('role', 'button');
            del.setAttribute('aria-label', `Delete row ${idx + 1}`);
            del.setAttribute('tabindex', '0');
            del.onclick = () => this.deleteRow(idx);
            del.onkeypress = (e) => {
                if (e.key === 'Enter' || e.key === ' ') this.deleteRow(idx);
            };
            tdDel.appendChild(del);
        }
        tr.appendChild(tdDel);

        tbody.appendChild(tr);
    },
    
    addNewRow() { this.save(); this.render(); },
    deleteRow(idx) { this.data.splice(idx, 1); this.save(); this.render(); this.calculate(); this.showToast('Row deleted'); },
    
    setUIFromConfig() {
        document.getElementById('sel-metric').value = this.config.metric;
        document.getElementById('sel-tau').value = this.config.tauMethod || 'reml';
        document.getElementById('sel-ci').value = this.config.ciMethod || 'z';
        document.getElementById('chk-small').checked = this.config.smallBetter;
    },
    
    updateReferenceSelect(ts) {
        const sel = document.getElementById('sel-ref');
        const tlist = ts || this.getTreatments();
        sel.innerHTML = tlist.map(t => `<option value="${sanitize(t)}">${sanitize(t)}</option>`).join('');
        if (tlist.includes(this.config.reference)) sel.value = this.config.reference;
        else if (tlist.length) { this.config.reference = tlist[0]; sel.value = tlist[0]; }
    },
    
    getTreatments() {
        const set = new Set();
        this.data.forEach(row => { if (row.t1) set.add(row.t1.trim()); if (row.t2) set.add(row.t2.trim()); });
        return Array.from(set).sort();
    },
    
    calculate() {
        this.config.metric = document.getElementById('sel-metric').value;
        this.config.reference = document.getElementById('sel-ref').value;
        this.config.smallBetter = document.getElementById('chk-small').checked;
        this.config.tauMethod = document.getElementById('sel-tau').value;
        this.config.ciMethod = document.getElementById('sel-ci').value;
        
        const contrasts = [], treatmentSet = new Set();
        this.data.forEach(row => {
            const es = parseFloat(row.es), se = parseFloat(row.se), t1 = (row.t1 || '').trim(), t2 = (row.t2 || '').trim();
            if (t1 && t2 && t1 !== t2 && isFinite(es) && isFinite(se) && se > 0) {
                contrasts.push({ study: row.study || 'Study', t1, t2, es, se, year: parseFloat(row.year) || 2020, rob: row.rob || 'low' });
                treatmentSet.add(t1); treatmentSet.add(t2);
            }
        });
        
        const treatments = Array.from(treatmentSet).sort();
        this.updateReferenceSelect(treatments);
        
        const validation = Engine.validateContrasts(contrasts);
        const warningsDiv = document.getElementById('data-warnings');
        
        if (!validation.valid) { warningsDiv.innerHTML = `<div class="alert alert-error mb-2"><strong>⚠️ Errors:</strong><br>${validation.errors.join('<br>')}</div>`; this.results = null; return; }
        if (validation.warnings.length > 0) warningsDiv.innerHTML = `<div class="alert alert-warning mb-2"><strong>⚠️ Warnings:</strong><br>${validation.warnings.join('<br>')}</div>`;
        else warningsDiv.innerHTML = '';
        
        if (contrasts.length < 1 || treatments.length < 2) { this.results = null; return; }
        
        const connected = Engine.isConnected(contrasts, treatments);
        if (!connected) { this.results = null; warningsDiv.innerHTML = '<div class="alert alert-error"><strong>⚠️</strong> Network disconnected.</div>'; return; }
        
        const tauResult = Engine.computeTau2(contrasts, treatments, this.config.tauMethod);
        const tau2 = tauResult.tau2;
        const nma = Engine.estimate(contrasts, treatments, tau2);
        if (!nma) { this.results = null; return; }
        
        const df = contrasts.length - treatments.length + 1;
        const useHKSJ = this.config.ciMethod === 'hksj';
        const pairwise = Engine.pairwise(nma.theta, nma.V, treatments, this.config.metric, tau2, df, useHKSJ);
        const pScores = Engine.pScores(nma.theta, nma.V, this.config.smallBetter);
        const ranking = treatments.map((t, i) => ({ treatment: t, pScore: pScores[i] })).sort((a, b) => b.pScore - a.pScore);
        const consistency = Engine.consistencyTest(contrasts, treatments, tau2);
        const directComps = Engine.directComparisons(contrasts);
        const nodeSplits = directComps.map(dc => Engine.nodeSplit(contrasts, treatments, dc.t1, dc.t2, tau2)).filter(ns => ns);
        const edgeWeights = Engine.edgeWeights(contrasts);
        const networkDiag = Engine.networkDiagnostics(contrasts, treatments);
        
        const lowRobContrasts = contrasts.filter(c => c.rob === 'low');
        let robSensitivity = null;
        if (lowRobContrasts.length >= 1) {
            const lowT = Array.from(new Set([...lowRobContrasts.map(c => c.t1), ...lowRobContrasts.map(c => c.t2)])).sort();
            if (lowT.length >= 2 && Engine.isConnected(lowRobContrasts, lowT)) {
                const lowTauR = Engine.computeTau2(lowRobContrasts, lowT, this.config.tauMethod);
                const lowNMA = Engine.estimate(lowRobContrasts, lowT, lowTauR.tau2);
                if (lowNMA) { const lowDf = lowRobContrasts.length - lowT.length + 1; robSensitivity = { treatments: lowT, pairwise: Engine.pairwise(lowNMA.theta, lowNMA.V, lowT, this.config.metric, lowTauR.tau2, lowDf, useHKSJ) }; }
            }
        }
        
        // ========== NEW: Advanced NMA Features ==========
        // 1. Contribution Matrix
        const contributionMatrix = Engine.contributionMatrix(contrasts, treatments, tau2);
        
        // 2. Q-profile CI for τ²
        const tau2CI = Engine.tau2CI_QProfile(contrasts, treatments, tau2);
        
        // 3. Comparison-adjusted Funnel Plot data
        const funnelData = Engine.comparisonAdjustedFunnel(contrasts, treatments, tau2);
        
        // 4. CINeMA confidence ratings
        const cinemaRatings = Engine.cinemaRating(contrasts, treatments, tau2, pairwise, consistency, true);
        
        // 5. Threshold Analysis
        const thresholdAnalysis = Engine.thresholdAnalysis(contrasts, treatments, tau2);
        
        // 6. SUCRA (alongside P-scores)
        const sucraResults = Engine.SUCRA(nma.theta, nma.V, this.config.smallBetter);
        
        // 7. League table with contribution shading
        const leagueWithContrib = Engine.leagueTableWithContributions(treatments, pairwise, contributionMatrix);
        
        // 8. Study importance
        const studyImportance = Engine.studyImportance(contrasts, treatments, tau2);
        
        this.results = { ...nma, tau2, tauConverged: tauResult.converged, tauIterations: tauResult.iterations, tauMessage: tauResult.message, tauAtBoundary: tauResult.atBoundary, treatments, contrasts, pairwise, pScores, ranking, consistency, nodeSplits, directComparisons: directComps, edgeWeights, connected, nStudies: new Set(contrasts.map(c => c.study)).size, networkDiag, robCounts: { low: contrasts.filter(c => c.rob === 'low').length, some: contrasts.filter(c => c.rob === 'some').length, high: contrasts.filter(c => c.rob === 'high').length }, robSensitivity, I2: Engine.I2(nma.Q, df), df, useHKSJ,
            // NEW advanced features
            tau2CI, contributionMatrix, funnelData, cinemaRatings, thresholdAnalysis, sucraResults, leagueWithContrib, studyImportance
        };
        this.draw();
    },
    
    draw() {
        const activeView = document.querySelector('.view.active')?.id;
        if (!this.results) return;
        const fns = { 'v-network': () => this.drawNetwork(), 'v-results': () => this.drawResults(), 'v-league': () => this.drawLeague(), 'v-ranking': () => this.drawRanking(), 'v-forest': () => this.drawForest(), 'v-consist': () => this.drawConsistency(), 'v-rob': () => this.drawROB(), 'v-advanced': () => this.drawAdvanced() };
        if (fns[activeView]) fns[activeView]();
    },
    
    drawNetwork() {
        const r = this.results;
        document.getElementById('s-treatments').textContent = r.treatments.length;
        document.getElementById('s-studies').textContent = r.nStudies;
        document.getElementById('s-comparisons').textContent = r.directComparisons.length;
        document.getElementById('s-density').textContent = (r.networkDiag.density * 100).toFixed(0) + '%';

        // Network geometry info
        const nLoops = r.contrasts.length - r.treatments.length + 1;
        const isOk = nLoops > 0;
        const geometryClass = isOk ? 'alert-success' : 'alert-warning';
        const geometryStatus = isOk ? '<br>✓ Closed loops.' : '<br>⚠️ Star network.';
        document.getElementById('network-info').innerHTML =
            `<div class="alert ${geometryClass}">` +
            `<strong>Geometry:</strong> ${r.treatments.length} nodes, ` +
            `${r.directComparisons.length} edges, ${nLoops} loops.${geometryStatus}</div>`;

        // Articulation points diagnostics
        const artPoints = r.networkDiag.articulationPoints;
        if (artPoints.length > 0) {
            const sanitizedPoints = artPoints.map(p => sanitize(p)).join(' or ');
            document.getElementById('network-diagnostics').innerHTML =
                `<div class="alert alert-warning"><strong>⚠️ Critical:</strong> ` +
                `Removing ${sanitizedPoints} disconnects network.</div>`;
        } else {
            document.getElementById('network-diagnostics').innerHTML =
                `<div class="alert alert-success"><strong>✓ Robust:</strong> ` +
                `No single removal disconnects network.</div>`;
        }

        // Build network graph
        const n = r.treatments.length;
        const angle = (2 * Math.PI) / n;
        const nodeX = r.treatments.map((_, i) => Math.cos(angle * i - Math.PI / 2));
        const nodeY = r.treatments.map((_, i) => Math.sin(angle * i - Math.PI / 2));
        const idx = {};
        r.treatments.forEach((t, i) => idx[t] = i);

        // Edge traces
        const traces = [];
        r.directComparisons.forEach(comp => {
            const i1 = idx[comp.t1];
            const i2 = idx[comp.t2];
            const key = [comp.t1, comp.t2].sort().join('|');
            const weight = r.edgeWeights[key] || 1;
            traces.push({
                x: [nodeX[i1], nodeX[i2]],
                y: [nodeY[i1], nodeY[i2]],
                mode: 'lines',
                line: { color: 'rgba(59,130,246,0.6)', width: Math.min(2 + weight * 2, 12) },
                hoverinfo: 'text',
                text: `${comp.t1} vs ${comp.t2}: ${weight} studies`,
                showlegend: false
            });
        });

        // Node trace
        traces.push({
            x: nodeX,
            y: nodeY,
            mode: 'markers+text',
            marker: {
                size: 36,
                color: r.treatments.map(t => artPoints.includes(t) ? '#f59e0b' : '#111820'),
                line: { color: '#3b82f6', width: 2 }
            },
            text: r.treatments,
            textposition: 'middle center',
            textfont: { color: '#f0f4f8', size: 9 },
            hoverinfo: 'text',
            hovertext: r.treatments.map((t, i) => `${t}\nP-Score: ${r.pScores[i].toFixed(FORMAT.PSCORE)}`),
            showlegend: false
        });

        Plotly.purge('plt-network');
        Plotly.newPlot('plt-network', traces, {
            paper_bgcolor: '#0a0f14',
            plot_bgcolor: '#0a0f14',
            margin: { l: 20, r: 20, t: 20, b: 20 },
            xaxis: { visible: false, range: [-1.6, 1.6] },
            yaxis: { visible: false, range: [-1.6, 1.6], scaleanchor: 'x' }
        }, { displayModeBar: false, responsive: true });
    },
    
    drawResults() {
        const r = this.results;
        const metric = this.config.metric;
        const isRatio = ['OR', 'RR'].includes(metric);
        const ref = this.config.reference || r.treatments[0];
        const nullVal = isRatio ? 1 : 0;

        // Update header badges and notes
        document.getElementById('tau-method-badge').textContent =
            `${this.config.tauMethod.toUpperCase()}${r.useHKSJ ? '+HKSJ' : ''}`;

        document.getElementById('results-note').innerHTML =
            `<strong>Reference:</strong> ${sanitize(ref)}. Values ${isRatio ? '&lt;1' : '&lt;0'} favour comparator.` +
            `${r.useHKSJ ? '<br><small>HKSJ t-distribution CIs.</small>' : ''}`;

        // Convergence info
        let convHtml = '';
        if (!r.tauConverged) {
            convHtml = `<div class="alert alert-warning">
                <strong>⚠️</strong> τ² did not converge. ${sanitize(r.tauMessage || '')}
            </div>`;
        } else if (r.tauAtBoundary) {
            convHtml = `<div class="alert alert-success">
                <strong>✓</strong> ${sanitize(r.tauMessage)}
            </div>`;
        }
        document.getElementById('convergence-info').innerHTML = convHtml;

        // Summary stats
        document.getElementById('r-treatments').textContent = r.treatments.length;
        document.getElementById('r-contrasts').textContent = r.contrasts.length;
        document.getElementById('r-tau2').textContent = r.tau2.toFixed(FORMAT.TAU);
        document.getElementById('r-i2').textContent = `${r.I2.toFixed(FORMAT.PERCENT)}%`;

        // Results table
        const vsRef = r.pairwise
            .filter(p => p.t2 === ref && p.t1 !== ref)
            .sort((a, b) => a.d - b.d);

        let html = `
            <table class="rank-table" role="table" aria-label="NMA Results">
                <thead>
                    <tr>
                        <th scope="col">Treatment</th>
                        <th scope="col">${sanitize(metric)}</th>
                        <th scope="col">95% CI</th>
                        <th scope="col">P-value</th>
                        <th scope="col">P-Score</th>
                    </tr>
                </thead>
                <tbody>`;

        vsRef.forEach(p => {
            const tidx = r.treatments.indexOf(p.t1);
            const pScore = r.pScores[tidx];
            const colorClass = p.sig ? (p.d < nullVal ? 'text-success' : 'text-error') : '';
            const pvalDisplay = p.pv < 0.001 ? '&lt;.001' : p.pv.toFixed(FORMAT.PVALUE);

            html += `
                <tr>
                    <td class="fw-500">${sanitize(p.t1)}</td>
                    <td class="mono ${colorClass}">${p.d.toFixed(FORMAT.EFFECT)}</td>
                    <td class="mono text-muted">[${p.dL.toFixed(FORMAT.CI)}, ${p.dH.toFixed(FORMAT.CI)}]</td>
                    <td class="mono">${pvalDisplay}</td>
                    <td class="mono">${pScore.toFixed(FORMAT.PSCORE)}</td>
                </tr>`;
        });

        html += '</tbody></table>';
        document.getElementById('results-table').innerHTML = html;
    },
    
    drawLeague() {
        const r = this.results;
        const metric = this.config.metric;
        const isRatio = ['OR', 'RR'].includes(metric);
        const nullVal = isRatio ? 1 : 0;

        // Build lookup for pairwise results
        const lookup = {};
        r.pairwise.forEach(p => lookup[`${p.t1}|${p.t2}`] = p);

        // Sort treatments by ranking
        const sortedTs = r.ranking.map(item => item.treatment);

        // Build header row
        let html = `
            <thead>
                <tr>
                    <th scope="col"></th>
                    ${sortedTs.map(t => `<th scope="col">${sanitize(t)}</th>`).join('')}
                </tr>
            </thead>
            <tbody>`;

        // Build data rows
        sortedTs.forEach(t1 => {
            html += `<tr><th scope="row">${sanitize(t1)}</th>`;

            sortedTs.forEach(t2 => {
                if (t1 === t2) {
                    // Diagonal: show P-score
                    const pScore = r.pScores[r.treatments.indexOf(t1)];
                    html += `<td class="diagonal">${pScore.toFixed(FORMAT.EFFECT)}</td>`;
                } else {
                    const p = lookup[`${t1}|${t2}`];
                    if (p) {
                        const sigClass = p.sig
                            ? (p.d < nullVal ? 'sig-positive' : 'sig-negative')
                            : '';
                        html += `
                            <td class="${sigClass}">
                                ${p.d.toFixed(FORMAT.EFFECT)}<br>
                                <span style="font-size:0.6rem;opacity:0.7">
                                    [${p.dL.toFixed(FORMAT.CI)}, ${p.dH.toFixed(FORMAT.CI)}]
                                </span>
                            </td>`;
                    } else {
                        html += '<td>-</td>';
                    }
                }
            });

            html += '</tr>';
        });

        html += '</tbody>';
        document.getElementById('league-table').innerHTML = html;
    },
    
    drawRanking() {
        const r = this.results;

        // Direction note
        document.getElementById('ranking-note').innerHTML =
            `<strong>Direction:</strong> ${this.config.smallBetter ? 'Lower=better' : 'Higher=better'}. P-Score 1=best, 0=worst.`;

        // Build ranking table
        let html = `
            <thead>
                <tr>
                    <th scope="col">Rank</th>
                    <th scope="col">Treatment</th>
                    <th scope="col">P-Score</th>
                    <th scope="col" aria-label="Progress"></th>
                </tr>
            </thead>
            <tbody>`;

        r.ranking.forEach((item, i) => {
            const progressWidth = (item.pScore * 100).toFixed(FORMAT.PERCENT);
            html += `
                <tr>
                    <td class="rank-number">${i + 1}</td>
                    <td class="rank-name">${sanitize(item.treatment)}</td>
                    <td class="rank-score">${item.pScore.toFixed(FORMAT.PSCORE)}</td>
                    <td>
                        <div class="progress-bar" role="progressbar" aria-valuenow="${progressWidth}" aria-valuemin="0" aria-valuemax="100">
                            <div class="progress-bar-fill" style="width:${progressWidth}%"></div>
                        </div>
                    </td>
                </tr>`;
        });

        html += '</tbody>';
        document.getElementById('ranking-table').innerHTML = html;

        // Draw bar chart
        Plotly.purge('plt-rank');
        Plotly.newPlot('plt-rank', [{
            x: r.ranking.map(i => i.treatment),
            y: r.ranking.map(i => i.pScore),
            type: 'bar',
            marker: {
                color: r.ranking.map((_, i) => `rgba(59,130,246,${1 - i * 0.08})`),
                line: { color: '#3b82f6', width: 1 }
            },
            text: r.ranking.map(i => i.pScore.toFixed(FORMAT.EFFECT)),
            textposition: 'outside',
            textfont: { color: '#f0f4f8', size: 10 }
        }], {
            paper_bgcolor: '#0a0f14',
            plot_bgcolor: '#0a0f14',
            margin: { l: 40, r: 20, t: 20, b: 100 },
            xaxis: { tickangle: -45, color: '#64748b', gridcolor: '#1e2836' },
            yaxis: { title: 'P-Score', range: [0, 1.15], color: '#64748b', gridcolor: '#1e2836' },
            font: { family: 'Inter', color: '#f0f4f8' }
        }, { displayModeBar: false, responsive: true });
    },
    
    drawForest() {
        const r = this.results;
        const metric = this.config.metric;
        const isRatio = ['OR', 'RR'].includes(metric);
        const ref = this.config.reference || r.treatments[0];
        const nullVal = isRatio ? 1 : 0;
        const showPI = document.getElementById('chk-pi').checked;

        const vs = r.pairwise.filter(p => p.t2 === ref && p.t1 !== ref).sort((a, b) => a.d - b.d);

        // Reference line trace
        const traces = [{
            x: [nullVal, nullVal],
            y: [-0.5, vs.length - 0.5],
            mode: 'lines',
            line: { color: '#1e2836', dash: 'dash' },
            showlegend: false
        }];

        // Prediction interval shading (if enabled)
        if (showPI) {
            traces.push({
                x: vs.map(p => p.predLo),
                y: vs.map((_, i) => i),
                mode: 'lines',
                line: { color: 'rgba(139,92,246,0.3)', width: 0 },
                showlegend: false,
                hoverinfo: 'skip'
            });
            traces.push({
                x: vs.map(p => p.predHi),
                y: vs.map((_, i) => i),
                mode: 'lines',
                line: { color: 'rgba(139,92,246,0.3)', width: 0 },
                fill: 'tonextx',
                fillcolor: 'rgba(139,92,246,0.15)',
                showlegend: false,
                hoverinfo: 'skip'
            });
        }

        // Main effect markers with error bars
        traces.push({
            x: vs.map(p => p.d),
            y: vs.map((_, i) => i),
            error_x: {
                type: 'data',
                symmetric: false,
                array: vs.map(p => p.dH - p.d),
                arrayminus: vs.map(p => p.d - p.dL),
                color: '#3b82f6',
                thickness: 2,
                width: 0
            },
            mode: 'markers',
            marker: {
                symbol: 'diamond',
                size: 12,
                color: vs.map(p => p.sig ? (p.d < nullVal ? '#10b981' : '#ef4444') : '#64748b')
            },
            text: vs.map(p => {
                const base = `${p.t1}: ${p.d.toFixed(FORMAT.EFFECT)} [${p.dL.toFixed(FORMAT.CI)}, ${p.dH.toFixed(FORMAT.CI)}]`;
                return showPI ? `${base}\nPI: [${p.predLo.toFixed(FORMAT.CI)}, ${p.predHi.toFixed(FORMAT.CI)}]` : base;
            }),
            hoverinfo: 'text',
            showlegend: false
        });

        Plotly.purge('plt-forest');
        Plotly.newPlot('plt-forest', traces, {
            paper_bgcolor: '#0a0f14',
            plot_bgcolor: '#0a0f14',
            margin: { l: 140, r: 30, t: 30, b: 50 },
            xaxis: {
                title: metric + (showPI ? ' (shaded=PI)' : ''),
                type: isRatio ? 'log' : 'linear',
                color: '#64748b',
                gridcolor: '#1e2836'
            },
            yaxis: {
                tickmode: 'array',
                tickvals: vs.map((_, i) => i),
                ticktext: vs.map(p => p.t1),
                color: '#f0f4f8'
            },
            font: { family: 'Inter', color: '#f0f4f8' }
        }, { displayModeBar: false, responsive: true });
    },
    
    drawConsistency() {
        const r = this.results;
        const cons = r.consistency;
        const metric = this.config.metric;
        const isRatio = ['OR', 'RR'].includes(metric);

        // Handle missing consistency data
        if (!cons) {
            document.getElementById('q-total').textContent = '-';
            document.getElementById('q-within').textContent = '-';
            document.getElementById('q-between').textContent = '-';
            document.getElementById('q-interpretation').innerHTML =
                '<div class="empty-state">Insufficient data.</div>';
            document.getElementById('node-split-results').innerHTML = '';
            return;
        }

        // Q statistics
        document.getElementById('q-total').textContent = cons.Qtotal.toFixed(FORMAT.Q_STAT);
        document.getElementById('q-within').textContent = cons.Qwithin.toFixed(FORMAT.Q_STAT);
        document.getElementById('q-between').textContent = cons.Qbetween.toFixed(FORMAT.Q_STAT);

        // Interpretation
        const alertClass = cons.inconsistent ? 'alert-warning' : 'alert-success';
        const pDisplay = cons.pBetween < 0.001 ? '<0.001' : cons.pBetween.toFixed(FORMAT.PVALUE);
        const statusText = cons.inconsistent ? '⚠️ Inconsistency (p<0.10).' : '✓ No inconsistency.';

        let interpHtml = `<div class="alert ${alertClass}">` +
            `<strong>Global:</strong> Q<sub>between</sub>=${cons.Qbetween.toFixed(FORMAT.Q_STAT)}, ` +
            `df=${cons.dfBetween}, p=${pDisplay}<br>${statusText}` +
            `<br><small class="text-muted">Designs: ${cons.nDesigns}</small></div>`;

        if (cons.dfWarning) {
            interpHtml += `<div class="alert alert-warning mt-2">` +
                `<strong>⚠️</strong> ${sanitize(cons.warningMessage)}</div>`;
        }
        document.getElementById('q-interpretation').innerHTML = interpHtml;

        // Node-split results
        const container = document.getElementById('node-split-results');
        if (!r.nodeSplits.length) {
            container.innerHTML = '<div class="empty-state">No comparisons with both direct and indirect evidence.</div>';
            return;
        }

        container.innerHTML = r.nodeSplits.map(ns => {
            const directVal = isRatio
                ? Math.exp(ns.direct.es).toFixed(FORMAT.EFFECT)
                : ns.direct.es.toFixed(FORMAT.EFFECT);
            const indirectVal = isRatio
                ? Math.exp(ns.indirect.es).toFixed(FORMAT.EFFECT)
                : ns.indirect.es.toFixed(FORMAT.EFFECT);
            const pVal = ns.pv < 0.001 ? '<.001' : ns.pv.toFixed(FORMAT.PVALUE);
            const statusClass = ns.inconsistent ? 'status-bad' : 'status-ok';
            const badgeClass = ns.inconsistent ? 'badge-bad' : 'badge-ok';
            const badgeText = ns.inconsistent ? 'Inconsistent' : 'Consistent';

            return `<div class="comparison-item ${statusClass}">` +
                `<div class="comparison-header">` +
                `<span class="comparison-title">${sanitize(ns.t1)} vs ${sanitize(ns.t2)}</span>` +
                `<span class="comparison-badge ${badgeClass}">${badgeText}</span>` +
                `</div>` +
                `<div class="comparison-grid">` +
                `<div><div class="comparison-label">Direct (n=${ns.direct.n})</div>` +
                `<div class="comparison-value">${directVal}</div></div>` +
                `<div><div class="comparison-label">Indirect</div>` +
                `<div class="comparison-value">${indirectVal}</div></div>` +
                `<div><div class="comparison-label">P-value</div>` +
                `<div class="comparison-value ${ns.inconsistent ? 'text-error' : ''}">${pVal}</div></div>` +
                `</div></div>`;
        }).join('');
    },
    
    drawROB() {
        const r = this.results;
        const metric = this.config.metric;
        const isRatio = ['OR', 'RR'].includes(metric);
        const ref = this.config.reference || r.treatments[0];
        const nullVal = isRatio ? 1 : 0;

        // ROB counts
        document.getElementById('rob-low-count').textContent = r.robCounts.low;
        document.getElementById('rob-some-count').textContent = r.robCounts.some;
        document.getElementById('rob-high-count').textContent = r.robCounts.high;

        // Helper to build ROB table rows
        const buildROBRow = (p) => {
            const colorClass = p.sig ? (p.d < nullVal ? 'text-success' : 'text-error') : '';
            return `<tr>` +
                `<td class="fw-500">${sanitize(p.t1)}</td>` +
                `<td class="mono ${colorClass}">${p.d.toFixed(FORMAT.EFFECT)}</td>` +
                `<td class="mono text-muted">[${p.dL.toFixed(FORMAT.CI)}, ${p.dH.toFixed(FORMAT.CI)}]</td>` +
                `</tr>`;
        };

        // Main analysis table
        const mainVs = r.pairwise.filter(p => p.t2 === ref && p.t1 !== ref).sort((a, b) => a.d - b.d);
        let mainHtml = '<table class="rank-table" style="font-size:0.8125rem;">' +
            `<thead><tr><th>Treatment</th><th>${sanitize(metric)}</th><th>95% CI</th></tr></thead><tbody>`;
        mainVs.forEach(p => { mainHtml += buildROBRow(p); });
        mainHtml += '</tbody></table>';
        document.getElementById('rob-all-studies').innerHTML = mainHtml;

        // Sensitivity analysis (low ROB only)
        if (r.robSensitivity) {
            const sensVs = r.robSensitivity.pairwise.filter(p => p.t2 === ref && p.t1 !== ref).sort((a, b) => a.d - b.d);
            let sensHtml = '<table class="rank-table" style="font-size:0.8125rem;">' +
                `<thead><tr><th>Treatment</th><th>${sanitize(metric)}</th><th>95% CI</th></tr></thead><tbody>`;
            sensVs.forEach(p => { sensHtml += buildROBRow(p); });
            sensHtml += '</tbody></table>';
            document.getElementById('rob-low-studies').innerHTML = sensHtml;

            // Build comparison plot
            const allTs = [...new Set([...mainVs.map(p => p.t1), ...sensVs.map(p => p.t1)])].sort();
            const mainLookup = {};
            const sensLookup = {};
            mainVs.forEach(p => mainLookup[p.t1] = p);
            sensVs.forEach(p => sensLookup[p.t1] = p);

            // Reference line trace
            const refLineTrace = {
                x: [nullVal, nullVal],
                y: [-0.5, allTs.length - 0.5],
                mode: 'lines',
                line: { color: '#1e2836', dash: 'dash' },
                showlegend: false
            };

            // All studies trace
            const allStudiesTrace = {
                x: allTs.map(t => mainLookup[t]?.d || null),
                y: allTs.map((_, i) => i - 0.12),
                error_x: {
                    type: 'data',
                    symmetric: false,
                    array: allTs.map(t => mainLookup[t] ? mainLookup[t].dH - mainLookup[t].d : 0),
                    arrayminus: allTs.map(t => mainLookup[t] ? mainLookup[t].d - mainLookup[t].dL : 0),
                    color: '#3b82f6',
                    thickness: 2,
                    width: 0
                },
                mode: 'markers',
                marker: { symbol: 'diamond', size: 10, color: '#3b82f6' },
                name: 'All Studies'
            };

            // Low ROB trace
            const lowROBTrace = {
                x: allTs.map(t => sensLookup[t]?.d || null),
                y: allTs.map((_, i) => i + 0.12),
                error_x: {
                    type: 'data',
                    symmetric: false,
                    array: allTs.map(t => sensLookup[t] ? sensLookup[t].dH - sensLookup[t].d : 0),
                    arrayminus: allTs.map(t => sensLookup[t] ? sensLookup[t].d - sensLookup[t].dL : 0),
                    color: '#8b5cf6',
                    thickness: 2,
                    width: 0
                },
                mode: 'markers',
                marker: { symbol: 'circle', size: 10, color: '#8b5cf6' },
                name: 'Low ROB Only'
            };

            Plotly.purge('plt-rob');
            Plotly.newPlot('plt-rob', [refLineTrace, allStudiesTrace, lowROBTrace], {
                paper_bgcolor: '#0a0f14',
                plot_bgcolor: '#0a0f14',
                margin: { l: 140, r: 20, t: 20, b: 40 },
                xaxis: {
                    title: metric,
                    type: isRatio ? 'log' : 'linear',
                    color: '#64748b',
                    gridcolor: '#1e2836'
                },
                yaxis: {
                    tickmode: 'array',
                    tickvals: allTs.map((_, i) => i),
                    ticktext: allTs,
                    color: '#f0f4f8'
                },
                font: { family: 'Inter', color: '#f0f4f8' },
                showlegend: true,
                legend: { x: 0.02, y: 0.98, bgcolor: 'rgba(0,0,0,0.5)' }
            }, { displayModeBar: false, responsive: true });
        } else {
            document.getElementById('rob-low-studies').innerHTML =
                '<div class="empty-state">Insufficient low ROB studies.</div>';
            Plotly.purge('plt-rob');
        }
    },
    
    drawAdvanced() {
        const r = this.results;
        if (!r) return;
        
        const metric = this.config.metric;
        const isRatio = ['OR', 'RR'].includes(metric);
        
        // τ² with Q-profile CI
        document.getElementById('adv-tau2').textContent = r.tau2.toFixed(FORMAT.TAU);
        if (r.tau2CI) {
            document.getElementById('adv-tau2-lo').textContent = r.tau2CI.lower.toFixed(FORMAT.TAU);
            document.getElementById('adv-tau2-hi').textContent = r.tau2CI.upper === Infinity ? '∞' : r.tau2CI.upper.toFixed(FORMAT.TAU);
        }
        
        // Threshold Robustness
        if (r.thresholdAnalysis) {
            document.getElementById('adv-robustness').textContent = (r.thresholdAnalysis.overallRobustness * 100).toFixed(0) + '%';
        }
        
        // Contribution Matrix Table
        if (r.contributionMatrix && r.contributionMatrix.directIndirect) {
            const ref = this.config.reference || r.treatments[0];
            const relevantKeys = Object.keys(r.contributionMatrix.directIndirect)
                .filter(k => k.includes(ref))
                .slice(0, 10);
            
            let html = '<table class="rank-table" style="font-size:0.75rem;"><thead><tr><th>Comparison</th><th>Direct %</th><th>Indirect %</th><th style="width:100px;">Proportion</th></tr></thead><tbody>';
            
            relevantKeys.forEach(key => {
                const di = r.contributionMatrix.directIndirect[key];
                const directPct = di.direct.toFixed(FORMAT.PERCENT);
                const indirectPct = di.indirect.toFixed(FORMAT.PERCENT);
                const barWidth = di.ratio * 100;
                
                html += `<tr>
                    <td class="fw-500">${sanitize(key.replace('|', ' vs '))}</td>
                    <td class="mono text-success">${directPct}%</td>
                    <td class="mono text-muted">${indirectPct}%</td>
                    <td><div class="progress-bar"><div class="progress-bar-fill" style="width:${barWidth}%"></div></div></td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            document.getElementById('adv-contributions').innerHTML = html;
        } else {
            document.getElementById('adv-contributions').innerHTML = '<div class="empty-state">Contribution matrix not available.</div>';
        }
        
        // CINeMA Ratings
        if (r.cinemaRatings) {
            const ref = this.config.reference || r.treatments[0];
            const ratings = Object.entries(r.cinemaRatings)
                .filter(([k]) => k.includes(ref))
                .slice(0, 10);
            
            let html = '<table class="rank-table" style="font-size:0.75rem;"><thead><tr><th>Comparison</th><th>Confidence</th><th>Imprecision</th><th>Heterogeneity</th><th>Incoherence</th></tr></thead><tbody>';
            
            ratings.forEach(([key, rating]) => {
                const confColor = rating.confidence === 'high' ? 'success' : 
                                 rating.confidence === 'moderate' ? 'warning' : 
                                 rating.confidence === 'low' ? 'warning' : 'error';
                
                const domainBadge = (concern) => {
                    if (concern === 'no concerns') return '<span class="text-success">●</span>';
                    if (concern === 'some concerns') return '<span class="text-warning">●</span>';
                    if (concern === 'major concerns') return '<span class="text-error">●</span>';
                    return '<span class="text-muted">○</span>';
                };
                
                html += `<tr>
                    <td class="fw-500">${sanitize(key.replace('|', ' vs '))}</td>
                    <td class="text-${confColor} fw-600">${sanitize(rating.confidence.toUpperCase())}</td>
                    <td>${domainBadge(rating.domains.imprecision)}</td>
                    <td>${domainBadge(rating.domains.heterogeneity)}</td>
                    <td>${domainBadge(rating.domains.incoherence)}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            html += '<div class="text-xs text-muted mt-2">● = concern level: <span class="text-success">●</span> none, <span class="text-warning">●</span> some, <span class="text-error">●</span> major</div>';
            document.getElementById('adv-cinema').innerHTML = html;
        } else {
            document.getElementById('adv-cinema').innerHTML = '<div class="empty-state">CINeMA ratings not available.</div>';
        }
        
        // Comparison-Adjusted Funnel Plot
        if (r.funnelData && r.funnelData.points) {
            const pts = r.funnelData.points;
            
            Plotly.purge('plt-funnel-adjusted');
            Plotly.newPlot('plt-funnel-adjusted', [{
                x: pts.map(p => p.x),
                y: pts.map(p => p.y),
                mode: 'markers',
                type: 'scatter',
                marker: { size: 8, color: '#3b82f6', opacity: 0.7 },
                text: pts.map(p => p.comparison),
                hovertemplate: '%{text}<br>Centered: %{x:.3f}<br>SE: %{y:.3f}<extra></extra>'
            }, {
                // Reference line at x=0
                x: [0, 0],
                y: [0, Math.max(...pts.map(p => p.y)) * 1.1],
                mode: 'lines',
                line: { color: '#64748b', dash: 'dash', width: 1 },
                showlegend: false
            }, {
                // Funnel boundaries (simplified)
                x: [-1.96 * Math.max(...pts.map(p => p.y)), 1.96 * Math.max(...pts.map(p => p.y))],
                y: [Math.max(...pts.map(p => p.y)), Math.max(...pts.map(p => p.y))],
                mode: 'lines',
                line: { color: '#64748b', width: 1 },
                showlegend: false
            }], {
                paper_bgcolor: '#0a0f14',
                plot_bgcolor: '#0a0f14',
                margin: { l: 50, r: 20, t: 10, b: 40 },
                xaxis: { title: 'Centered Effect', color: '#64748b', gridcolor: '#1e2836', zeroline: false },
                yaxis: { title: 'SE', autorange: 'reversed', color: '#64748b', gridcolor: '#1e2836' },
                font: { family: 'Inter', color: '#f0f4f8', size: 10 },
                showlegend: false
            }, { displayModeBar: false, responsive: true });
            
            // Egger's test result
            if (r.funnelData.eggerTest) {
                const eg = r.funnelData.eggerTest;
                const alertClass = eg.significant ? 'alert-warning' : 'alert-success';
                const pDisplay = eg.p < 0.001 ? '<0.001' : eg.p.toFixed(FORMAT.PVALUE);
                document.getElementById('adv-egger').innerHTML =
                    `<div class="alert ${alertClass}" style="font-size:0.75rem;">` +
                    `<strong>Egger's Test:</strong> Intercept = ${eg.intercept.toFixed(FORMAT.PVALUE)}, ` +
                    `p = ${pDisplay} ${eg.significant ? '(Asymmetry detected)' : '(No asymmetry)'}</div>`;
            }
        } else {
            Plotly.purge('plt-funnel-adjusted');
            document.getElementById('adv-egger').innerHTML = '';
        }
        
        // SUCRA vs P-scores
        if (r.sucraResults) {
            let html = '<table class="rank-table" style="font-size:0.75rem;"><thead><tr><th>Treatment</th><th>P-score</th><th>SUCRA</th><th>Δ</th></tr></thead><tbody>';
            
            r.treatments.forEach((t, i) => {
                const pScore = r.sucraResults.pscores[i];
                const sucra = r.sucraResults.sucra[i];
                const diff = Math.abs(pScore - sucra);
                
                html += `<tr>
                    <td class="fw-500">${sanitize(t)}</td>
                    <td class="mono">${(pScore * 100).toFixed(FORMAT.PERCENT)}%</td>
                    <td class="mono">${(sucra * 100).toFixed(FORMAT.PERCENT)}%</td>
                    <td class="mono ${diff < 0.05 ? 'text-success' : 'text-warning'}">${(diff * 100).toFixed(FORMAT.PERCENT)}%</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            html += `<div class="text-xs text-muted mt-2">Agreement: ${r.sucraResults.agreement ? '✓ P-scores ≈ SUCRA' : '⚠️ Values differ'}</div>`;
            document.getElementById('adv-sucra').innerHTML = html;
        } else {
            document.getElementById('adv-sucra').innerHTML = '<div class="empty-state">SUCRA not available.</div>';
        }
        
        // Threshold Analysis
        if (r.thresholdAnalysis && r.thresholdAnalysis.comparisons) {
            let html = '<table class="rank-table" style="font-size:0.75rem;"><thead><tr><th>Comparison</th><th>Estimate</th><th>Min Threshold</th><th>Robust?</th></tr></thead><tbody>';
            
            r.thresholdAnalysis.comparisons.slice(0, 10).forEach(comp => {
                const est = isRatio ? Math.exp(comp.estimate).toFixed(FORMAT.PVALUE) : comp.estimate.toFixed(FORMAT.PVALUE);
                const threshold = comp.minThreshold === Infinity ? '∞' : comp.minThreshold.toFixed(FORMAT.EFFECT);
                
                html += `<tr>
                    <td class="fw-500">${sanitize(comp.t1)} vs ${sanitize(comp.t2)}</td>
                    <td class="mono">${est}</td>
                    <td class="mono">${threshold}</td>
                    <td class="${comp.isRobust ? 'text-success' : 'text-warning'}">${comp.isRobust ? '✓' : '⚠️'}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            document.getElementById('adv-threshold').innerHTML = html;
        } else {
            document.getElementById('adv-threshold').innerHTML = '<div class="empty-state">Threshold analysis not available.</div>';
        }
        
        // Study Importance
        if (r.studyImportance) {
            let html = '<table class="rank-table" style="font-size:0.75rem;"><thead><tr><th>Study</th><th>Comparison</th><th>Importance</th><th style="width:80px;"></th></tr></thead><tbody>';
            
            r.studyImportance.slice(0, 10).forEach(s => {
                const barWidth = s.importance * 100;
                const barColor = s.critical ? 'var(--error)' : 
                                s.importance > 0.5 ? 'var(--warning)' : 'var(--accent-blue)';
                
                html += `<tr>
                    <td class="fw-500">${sanitize(s.study)}</td>
                    <td class="text-muted">${sanitize(s.t1)} vs ${sanitize(s.t2)}</td>
                    <td class="mono ${s.critical ? 'text-error' : ''}">${(s.importance * 100).toFixed(FORMAT.PERCENT)}%${s.critical ? ' (critical)' : ''}</td>
                    <td><div class="progress-bar"><div style="height:100%;width:${barWidth}%;background:${barColor};border-radius:4px;"></div></div></td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            document.getElementById('adv-importance').innerHTML = html;
        } else {
            document.getElementById('adv-importance').innerHTML = '<div class="empty-state">Study importance not available.</div>';
        }
    },
    
    runValidation() {
        const tests = Validation.runAll();
        this.renderValidation(tests);
        const passed = tests.filter(t => t.pass).length;
        const failed = tests.filter(t => !t.pass).length;
        this.showToast(`Validation complete: ${passed} passed, ${failed} failed`);
    },
    
    renderValidation(tests) {
        if (!tests) tests = Validation.runAll();
        
        const passed = tests.filter(t => t.pass).length;
        const failed = tests.filter(t => !t.pass).length;
        
        document.getElementById('tests-passed').textContent = passed;
        document.getElementById('tests-failed').textContent = failed;
        document.getElementById('r-agreement').textContent = tests.find(t => t.name === 'R netmeta Comparison')?.pass ? '✓' : '✗';
        
        const container = document.getElementById('validation-results');
        container.innerHTML = tests.map((test, i) => `
            <div class="test-item ${test.pass ? 'passed' : 'failed'}">
                <div class="test-header">
                    <span class="test-name">${i + 1}. ${test.name}</span>
                    <span class="test-status ${test.pass ? 'pass' : 'fail'}">${test.pass ? 'PASS' : 'FAIL'}</span>
                </div>
                <div class="test-details">
                    <strong>${test.description}</strong><br>
                    <code>${test.details}</code>
                </div>
            </div>
        `).join('');
    },
    
    // Mapping of view IDs to tab text for robust tab switching
    viewTabMap: {
        'data': 'Data',
        'network': 'Network',
        'results': 'Results',
        'league': 'League',
        'ranking': 'Ranking',
        'forest': 'Forest',
        'consist': 'Consistency',
        'rob': 'ROB-NMA',
        'advanced': '★ Advanced',
        'valid': '✓ Validation'
    },

    switchView(view) {
        // Update view visibility
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        const targetView = document.getElementById('v-' + view);
        if (targetView) {
            targetView.classList.add('active');
        }

        // Update tab active state using the view-tab mapping
        const tabText = this.viewTabMap[view];
        document.querySelectorAll('.tab').forEach(t => {
            t.classList.remove('active');
            if (tabText && t.textContent.trim() === tabText) {
                t.classList.add('active');
            }
        });

        setTimeout(() => this.draw(), 50);
    },
    
    toggleModal() { document.getElementById('modal-overlay').classList.toggle('show'); },
    
    showToast(msg, isError = false) {
        const toast = document.getElementById('toast');
        document.getElementById('toast-message').textContent = msg;
        toast.classList.toggle('error', isError);
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3500);
    },
    
    copyLeagueTable() {
        const r = this.results;
        if (!r) return;

        const lookup = {};
        r.pairwise.forEach(p => lookup[`${p.t1}|${p.t2}`] = p);

        let tsv = '\t' + r.treatments.join('\t') + '\n';
        r.treatments.forEach(t1 => {
            tsv += t1;
            r.treatments.forEach(t2 => {
                if (t1 === t2) {
                    tsv += '\t—';
                } else {
                    const p = lookup[`${t1}|${t2}`];
                    tsv += '\t' + (p
                        ? `${p.d.toFixed(FORMAT.EFFECT)} [${p.dL.toFixed(FORMAT.CI)}, ${p.dH.toFixed(FORMAT.CI)}]`
                        : '-');
                }
            });
            tsv += '\n';
        });

        navigator.clipboard.writeText(tsv).then(() => this.showToast('Copied to clipboard'));
    },

    /**
     * Cleanup method to remove event listeners and clear resources
     * Call this when destroying the app instance
     */
    destroy() {
        // Remove event listeners
        if (this.resizeHandler) {
            window.removeEventListener('resize', this.resizeHandler);
        }
        if (this.inputHandler) {
            const tableContainer = document.querySelector('.table-container');
            if (tableContainer) {
                tableContainer.removeEventListener('input', this.inputHandler);
            }
        }

        // Clear timeouts
        clearTimeout(this.saveTimeout);

        // Purge Plotly instances to free memory
        const plotIds = [
            'plt-network',
            'plt-rank',
            'plt-forest',
            'plt-rob',
            'plt-funnel-adjusted'
        ];
        plotIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                try {
                    Plotly.purge(id);
                } catch (e) {
                    logError(`Purging Plotly instance ${id}`, e);
                }
            }
        });

        // Reset state
        this.eventListenersSetup = false;
        this.results = null;
    }
};

// Initialize
if (typeof Plotly !== 'undefined') app.init();
else window.addEventListener('load', () => app.init());
</script>

</body> </html>
